package java.lang.invoke;
final class MethodTypeForm
{
final java.lang.Object argToSlotTable;

final java.lang.Object slotToArgTable;

final java.lang.Object argCounts;

final java.lang.Object primCounts;

final java.lang.Object erasedType;

final java.lang.Object basicType;

final java.lang.Object methodHandles;

final static java.lang.Object MH_BASIC_INV;

final static java.lang.Object MH_NF_INV;

final static java.lang.Object MH_UNINIT_CS;

final static java.lang.Object MH_LIMIT;

final java.lang.Object lambdaForms;

final static java.lang.Object LF_INVVIRTUAL;

final static java.lang.Object LF_INVSTATIC;

final static java.lang.Object LF_INVSPECIAL;

final static java.lang.Object LF_NEWINVSPECIAL;

final static java.lang.Object LF_INVINTERFACE;

final static java.lang.Object LF_INVSTATIC_INIT;

final static java.lang.Object LF_INTERPRET;

final static java.lang.Object LF_REBIND;

final static java.lang.Object LF_DELEGATE;

final static java.lang.Object LF_DELEGATE_BLOCK_INLINING;

final static java.lang.Object LF_EX_LINKER;

final static java.lang.Object LF_EX_INVOKER;

final static java.lang.Object LF_GEN_LINKER;

final static java.lang.Object LF_GEN_INVOKER;

final static java.lang.Object LF_CS_LINKER;

final static java.lang.Object LF_MH_LINKER;

final static java.lang.Object LF_GWC;

final static java.lang.Object LF_GWT;

final static java.lang.Object LF_LIMIT;

final public static java.lang.Object NO_CHANGE;

final public static java.lang.Object ERASE;

final public static java.lang.Object WRAP;

final public static java.lang.Object UNWRAP;

final public static java.lang.Object INTS;

final public static java.lang.Object LONGS;

final public static java.lang.Object RAW_RETURN;

public java.lang.invoke.MethodType erasedType()
{

}

public java.lang.invoke.MethodType basicType()
{

}

private boolean assertIsBasicType()
{

}

public java.lang.invoke.MethodHandle cachedMethodHandle(java.lang.Object arg0)
{

}

public synchronized java.lang.invoke.MethodHandle setCachedMethodHandle(java.lang.Object arg0, java.lang.Object arg1)
{

}

public java.lang.invoke.LambdaForm cachedLambdaForm(java.lang.Object arg0)
{

}

public synchronized java.lang.invoke.LambdaForm setCachedLambdaForm(java.lang.Object arg0, java.lang.Object arg1)
{

}

protected void <init>(java.lang.Object arg0)
{

}

private static long pack(java.lang.Object arg0, java.lang.Object arg1, java.lang.Object arg2, java.lang.Object arg3)
{

}

private static char unpack(java.lang.Object arg0, java.lang.Object arg1)
{

}

public int parameterCount()
{

}

public int parameterSlotCount()
{

}

public int returnCount()
{

}

public int returnSlotCount()
{

}

public int primitiveParameterCount()
{

}

public int longPrimitiveParameterCount()
{

}

public int primitiveReturnCount()
{

}

public int longPrimitiveReturnCount()
{

}

public boolean hasPrimitives()
{

}

public boolean hasNonVoidPrimitives()
{

}

public boolean hasLongPrimitives()
{

}

public int parameterToArgSlot(java.lang.Object arg0)
{

}

public int argSlotToParameter(java.lang.Object arg0)
{

}

static java.lang.invoke.MethodTypeForm findForm(java.lang.Object arg0)
{

}

public static java.lang.invoke.MethodType canonicalize(java.lang.Object arg0, java.lang.Object arg1, java.lang.Object arg2)
{

}

static java.lang.Class canonicalize(java.lang.Object arg0, java.lang.Object arg1)
{

}

static java.lang.Class[] canonicalizeAll(java.lang.Object arg0, java.lang.Object arg1)
{

}

public java.lang.String toString()
{

}

static void <clinit>()
{

}


}
