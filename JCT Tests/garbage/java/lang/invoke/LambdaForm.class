package java.lang.invoke;
class LambdaForm
{
final static class BasicType
extends java.lang.Enum
{
final public static java.lang.Object L_TYPE;

final public static java.lang.Object I_TYPE;

final public static java.lang.Object J_TYPE;

final public static java.lang.Object F_TYPE;

final public static java.lang.Object D_TYPE;

final public static java.lang.Object V_TYPE;

final static java.lang.Object ALL_TYPES;

final static java.lang.Object ARG_TYPES;

final static java.lang.Object ARG_TYPE_LIMIT;

final static java.lang.Object TYPE_LIMIT;

final private java.lang.Object btChar;

final private java.lang.Object btClass;

final private java.lang.Object btWrapper;

public static java.lang.invoke.LambdaForm.BasicType[] values()
{

}

public static java.lang.invoke.LambdaForm.BasicType valueOf(java.lang.Object arg0)
{

}

private void <init>(java.lang.Object arg0, java.lang.Object arg1, java.lang.Object arg2)
{

}

char basicTypeChar()
{

}

java.lang.Class basicTypeClass()
{

}

sun.invoke.util.Wrapper basicTypeWrapper()
{

}

int basicTypeSlots()
{

}

static java.lang.invoke.LambdaForm.BasicType basicType(java.lang.Object arg0)
{

}

static java.lang.invoke.LambdaForm.BasicType basicType(java.lang.Object arg0)
{

}

static java.lang.invoke.LambdaForm.BasicType basicType(java.lang.Object arg0)
{

}

static java.lang.invoke.LambdaForm.BasicType basicType(java.lang.Object arg0)
{

}

static char basicTypeChar(java.lang.Object arg0)
{

}

static java.lang.invoke.LambdaForm.BasicType[] basicTypes(java.lang.Object arg0)
{

}

static java.lang.invoke.LambdaForm.BasicType[] basicTypes(java.lang.Object arg0)
{

}

static byte[] basicTypesOrd(java.lang.Object arg0)
{

}

static boolean isBasicTypeChar(java.lang.Object arg0)
{

}

static boolean isArgBasicTypeChar(java.lang.Object arg0)
{

}

private static boolean checkBasicType()
{

}

static void <clinit>()
{

}


}

abstract static interface Compiled
extends java.lang.annotation.Annotation
{

}

abstract static interface Hidden
extends java.lang.annotation.Annotation
{

}

final static class Name
{
final java.lang.Object type;

private java.lang.Object index;

final java.lang.Object function;

final java.lang.Object constraint;

final java.lang.Object arguments;

private void <init>(java.lang.Object arg0, java.lang.Object arg1, java.lang.Object arg2, java.lang.Object arg3)
{

}

private void <init>(java.lang.Object arg0, java.lang.Object arg1)
{

}

void <init>(java.lang.Object arg0, java.lang.Object arg1)
{

}

void <init>(java.lang.Object arg0, java.lang.Object arg1)
{

}

void <init>(java.lang.Object arg0, java.lang.Object arg1)
{

}

void <init>(java.lang.Object arg0, java.lang.Object arg1)
{

}

void <init>(java.lang.Object arg0, java.lang.Object arg1)
{

}

void <init>(java.lang.Object arg0)
{

}

java.lang.invoke.LambdaForm.BasicType type()
{

}

int index()
{

}

boolean initIndex(java.lang.Object arg0)
{

}

char typeChar()
{

}

void resolve()
{

}

java.lang.invoke.LambdaForm.Name newIndex(java.lang.Object arg0)
{

}

java.lang.invoke.LambdaForm.Name cloneWithIndex(java.lang.Object arg0)
{

}

java.lang.invoke.LambdaForm.Name withConstraint(java.lang.Object arg0)
{

}

java.lang.invoke.LambdaForm.Name replaceName(java.lang.Object arg0, java.lang.Object arg1)
{

}

java.lang.invoke.LambdaForm.Name replaceNames(java.lang.Object arg0, java.lang.Object arg1, java.lang.Object arg2, java.lang.Object arg3)
{

}

void internArguments()
{

}

boolean isParam()
{

}

boolean isConstantZero()
{

}

public java.lang.String toString()
{

}

public java.lang.String debugString()
{

}

public java.lang.String paramString()
{

}

public java.lang.String exprString()
{

}

static boolean typesMatch(java.lang.Object arg0, java.lang.Object arg1)
{

}

int lastUseIndex(java.lang.Object arg0)
{

}

int useCount(java.lang.Object arg0)
{

}

boolean contains(java.lang.Object arg0)
{

}

public boolean equals(java.lang.Object arg0)
{

}

public boolean equals(java.lang.Object arg0)
{

}

public int hashCode()
{

}

static void <clinit>()
{

}


}

static class NamedFunction
{
final java.lang.Object member;

java.lang.Object resolvedHandle;

java.lang.Object invoker;

final static java.lang.Object INVOKER_METHOD_TYPE;

void <init>(java.lang.Object arg0)
{

}

void <init>(java.lang.Object arg0, java.lang.Object arg1)
{

}

void <init>(java.lang.Object arg0)
{

}

private static boolean isInvokeBasic(java.lang.Object arg0)
{

}

void <init>(java.lang.Object arg0)
{

}

void <init>(java.lang.Object arg0)
{

}

void <init>(java.lang.Object arg0)
{

}

java.lang.invoke.MethodHandle resolvedHandle()
{

}

void resolve()
{

}

public boolean equals(java.lang.Object arg0)
{

}

public int hashCode()
{

}

static void initializeInvokers()
{

}

static java.lang.Object invoke__V(java.lang.Object arg0, java.lang.Object arg1) throws java.lang.Throwable
{

}

static java.lang.Object invoke_L_V(java.lang.Object arg0, java.lang.Object arg1) throws java.lang.Throwable
{

}

static java.lang.Object invoke_LL_V(java.lang.Object arg0, java.lang.Object arg1) throws java.lang.Throwable
{

}

static java.lang.Object invoke_LLL_V(java.lang.Object arg0, java.lang.Object arg1) throws java.lang.Throwable
{

}

static java.lang.Object invoke_LLLL_V(java.lang.Object arg0, java.lang.Object arg1) throws java.lang.Throwable
{

}

static java.lang.Object invoke_LLLLL_V(java.lang.Object arg0, java.lang.Object arg1) throws java.lang.Throwable
{

}

static java.lang.Object invoke__L(java.lang.Object arg0, java.lang.Object arg1) throws java.lang.Throwable
{

}

static java.lang.Object invoke_L_L(java.lang.Object arg0, java.lang.Object arg1) throws java.lang.Throwable
{

}

static java.lang.Object invoke_LL_L(java.lang.Object arg0, java.lang.Object arg1) throws java.lang.Throwable
{

}

static java.lang.Object invoke_LLL_L(java.lang.Object arg0, java.lang.Object arg1) throws java.lang.Throwable
{

}

static java.lang.Object invoke_LLLL_L(java.lang.Object arg0, java.lang.Object arg1) throws java.lang.Throwable
{

}

static java.lang.Object invoke_LLLLL_L(java.lang.Object arg0, java.lang.Object arg1) throws java.lang.Throwable
{

}

private static boolean arityCheck(java.lang.Object arg0, java.lang.Object arg1, java.lang.Object arg2)
{

}

private static boolean arityCheck(java.lang.Object arg0, java.lang.Object arg1, java.lang.Object arg2, java.lang.Object arg3)
{

}

private static java.lang.invoke.MethodHandle computeInvoker(java.lang.Object arg0)
{

}

java.lang.Object invokeWithArguments(java.lang.Object arg0) throws java.lang.Throwable
{

}

java.lang.Object invokeWithArgumentsTracing(java.lang.Object arg0) throws java.lang.Throwable
{

}

private java.lang.invoke.MethodHandle invoker()
{

}

private static boolean checkArgumentTypes(java.lang.Object arg0, java.lang.Object arg1)
{

}

java.lang.invoke.MethodType methodType()
{

}

java.lang.invoke.MemberName member()
{

}

private boolean assertMemberIsConsistent()
{

}

java.lang.Class memberDeclaringClassOrNull()
{

}

java.lang.invoke.LambdaForm.BasicType returnType()
{

}

java.lang.invoke.LambdaForm.BasicType parameterType(java.lang.Object arg0)
{

}

int arity()
{

}

public java.lang.String toString()
{

}

public boolean isIdentity()
{

}

public boolean isConstantZero()
{

}

public java.lang.invoke.MethodHandleImpl.Intrinsic intrinsicName()
{

}

static void <clinit>()
{

}


}

final java.lang.Object arity;

final java.lang.Object result;

final java.lang.Object forceInline;

final java.lang.Object customized;

final java.lang.Object names;

final java.lang.Object debugName;

java.lang.Object vmentry;

private java.lang.Object isCompiled;

volatile java.lang.Object transformCache;

final public static java.lang.Object VOID_RESULT;

final public static java.lang.Object LAST_RESULT;

final private static java.lang.Object USE_PREDEFINED_INTERPRET_METHODS;

final private static java.lang.Object COMPILE_THRESHOLD;

private java.lang.Object invocationCounter;

final static java.lang.Object INTERNED_ARGUMENT_LIMIT;

final private static java.lang.Object INTERNED_ARGUMENTS;

final private static java.lang.Object IMPL_NAMES;

final private static java.lang.Object LF_identityForm;

final private static java.lang.Object LF_zeroForm;

final private static java.lang.Object NF_identity;

final private static java.lang.Object NF_zero;

final private static java.lang.Object DEBUG_NAME_COUNTERS;

final private static java.lang.Object TRACE_INTERPRETER;

void <init>(java.lang.Object arg0, java.lang.Object arg1, java.lang.Object arg2, java.lang.Object arg3)
{

}

void <init>(java.lang.Object arg0, java.lang.Object arg1, java.lang.Object arg2, java.lang.Object arg3, java.lang.Object arg4, java.lang.Object arg5)
{

}

void <init>(java.lang.Object arg0, java.lang.Object arg1, java.lang.Object arg2)
{

}

void <init>(java.lang.Object arg0, java.lang.Object arg1, java.lang.Object arg2, java.lang.Object arg3)
{

}

void <init>(java.lang.Object arg0, java.lang.Object arg1, java.lang.Object arg2, java.lang.Object arg3)
{

}

void <init>(java.lang.Object arg0, java.lang.Object arg1, java.lang.Object arg2, java.lang.Object arg3, java.lang.Object arg4)
{

}

private static java.lang.invoke.LambdaForm.Name[] buildNames(java.lang.Object arg0, java.lang.Object arg1, java.lang.Object arg2)
{

}

private void <init>(java.lang.Object arg0)
{

}

private static java.lang.invoke.LambdaForm.Name[] buildEmptyNames(java.lang.Object arg0, java.lang.Object arg1)
{

}

private static int fixResult(java.lang.Object arg0, java.lang.Object arg1)
{

}

private static java.lang.String fixDebugName(java.lang.Object arg0)
{

}

private static boolean namesOK(java.lang.Object arg0, java.lang.Object arg1)
{

}

java.lang.invoke.LambdaForm customize(java.lang.Object arg0)
{

}

java.lang.invoke.LambdaForm uncustomize()
{

}

private int normalize()
{

}

boolean nameRefsAreLegal()
{

}

java.lang.invoke.LambdaForm.BasicType returnType()
{

}

java.lang.invoke.LambdaForm.BasicType parameterType(java.lang.Object arg0)
{

}

java.lang.invoke.LambdaForm.Name parameter(java.lang.Object arg0)
{

}

java.lang.Object parameterConstraint(java.lang.Object arg0)
{

}

int arity()
{

}

int expressionCount()
{

}

java.lang.invoke.MethodType methodType()
{

}

final java.lang.String basicTypeSignature()
{

}

static int signatureArity(java.lang.Object arg0)
{

}

static java.lang.invoke.LambdaForm.BasicType signatureReturn(java.lang.Object arg0)
{

}

static boolean isValidSignature(java.lang.Object arg0)
{

}

static java.lang.invoke.MethodType signatureType(java.lang.Object arg0)
{

}

public void prepare()
{

}

java.lang.invoke.MemberName compileToBytecode()
{

}

private static void computeInitialPreparedForms()
{

}

static java.lang.Object interpret_L(java.lang.Object arg0) throws java.lang.Throwable
{

}

static java.lang.Object interpret_L(java.lang.Object arg0, java.lang.Object arg1) throws java.lang.Throwable
{

}

static java.lang.Object interpret_L(java.lang.Object arg0, java.lang.Object arg1, java.lang.Object arg2) throws java.lang.Throwable
{

}

private static java.lang.invoke.LambdaForm getPreparedForm(java.lang.Object arg0)
{

}

private static boolean argumentTypesMatch(java.lang.Object arg0, java.lang.Object arg1)
{

}

private static boolean valueMatches(java.lang.Object arg0, java.lang.Object arg1, java.lang.Object arg2)
{

}

private static boolean returnTypesMatch(java.lang.Object arg0, java.lang.Object arg1, java.lang.Object arg2)
{

}

private static boolean checkInt(java.lang.Object arg0, java.lang.Object arg1)
{

}

private static boolean checkRef(java.lang.Object arg0, java.lang.Object arg1)
{

}

java.lang.Object interpretWithArguments(java.lang.Object arg0) throws java.lang.Throwable
{

}

java.lang.Object interpretName(java.lang.Object arg0, java.lang.Object arg1) throws java.lang.Throwable
{

}

private void checkInvocationCounter()
{

}

java.lang.Object interpretWithArgumentsTracing(java.lang.Object arg0) throws java.lang.Throwable
{

}

static void traceInterpreter(java.lang.Object arg0, java.lang.Object arg1, java.lang.Object arg2)
{

}

static void traceInterpreter(java.lang.Object arg0, java.lang.Object arg1)
{

}

private boolean arityCheck(java.lang.Object arg0)
{

}

private boolean resultCheck(java.lang.Object arg0, java.lang.Object arg1)
{

}

private boolean isEmpty()
{

}

public java.lang.String toString()
{

}

public boolean equals(java.lang.Object arg0)
{

}

public boolean equals(java.lang.Object arg0)
{

}

public int hashCode()
{

}

java.lang.invoke.LambdaFormEditor editor()
{

}

boolean contains(java.lang.Object arg0)
{

}

java.lang.invoke.LambdaForm addArguments(java.lang.Object arg0, java.lang.Object arg1)
{

}

java.lang.invoke.LambdaForm addArguments(java.lang.Object arg0, java.lang.Object arg1)
{

}

java.lang.invoke.LambdaForm permuteArguments(java.lang.Object arg0, java.lang.Object arg1, java.lang.Object arg2)
{

}

static boolean permutedTypesMatch(java.lang.Object arg0, java.lang.Object arg1, java.lang.Object arg2, java.lang.Object arg3)
{

}

public static java.lang.String basicTypeSignature(java.lang.Object arg0)
{

}

public static java.lang.String shortenSignature(java.lang.Object arg0)
{

}

int lastUseIndex(java.lang.Object arg0)
{

}

int useCount(java.lang.Object arg0)
{

}

static java.lang.invoke.LambdaForm.Name argument(java.lang.Object arg0, java.lang.Object arg1)
{

}

static java.lang.invoke.LambdaForm.Name argument(java.lang.Object arg0, java.lang.Object arg1)
{

}

static java.lang.invoke.LambdaForm.Name internArgument(java.lang.Object arg0)
{

}

static java.lang.invoke.LambdaForm.Name[] arguments(java.lang.Object arg0, java.lang.Object arg1)
{

}

static java.lang.invoke.LambdaForm.Name[] arguments(java.lang.Object arg0, java.lang.Object arg1)
{

}

static java.lang.invoke.LambdaForm.Name[] arguments(java.lang.Object arg0, java.lang.Object arg1)
{

}

static java.lang.invoke.LambdaForm.Name[] arguments(java.lang.Object arg0, java.lang.Object arg1)
{

}

static java.lang.invoke.LambdaForm.Name[] arguments(java.lang.Object arg0, java.lang.Object arg1)
{

}

static java.lang.invoke.LambdaForm identityForm(java.lang.Object arg0)
{

}

static java.lang.invoke.LambdaForm zeroForm(java.lang.Object arg0)
{

}

static java.lang.invoke.LambdaForm.NamedFunction identity(java.lang.Object arg0)
{

}

static java.lang.invoke.LambdaForm.NamedFunction constantZero(java.lang.Object arg0)
{

}

private static void createIdentityForms()
{

}

private static int identity_I(java.lang.Object arg0)
{

}

private static long identity_J(java.lang.Object arg0)
{

}

private static float identity_F(java.lang.Object arg0)
{

}

private static double identity_D(java.lang.Object arg0)
{

}

private static java.lang.Object identity_L(java.lang.Object arg0)
{

}

private static void identity_V()
{

}

private static int zero_I()
{

}

private static long zero_J()
{

}

private static float zero_F()
{

}

private static double zero_D()
{

}

private static java.lang.Object zero_L()
{

}

private static void zero_V()
{

}

static void <clinit>()
{

}


}
