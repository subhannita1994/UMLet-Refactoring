/***** CLAIRE Compilation of file C:\Docume~1\Yann\Work\Ptidej~2\PaLM\v1.324\p-symbolic.cl 
         [version 3.2.52 / safety 5] Thu Feb 13 21:14:40 2003 *****/

#include <claire.h>
#include <Kernel.h>
#include <Core.h>
#include <choco.h>
#include <ice.h>
#include <palm.h>

// Implémentation d'un système d'explication en claire/choco
// (c) 2001 - Narendra Jussien - EMN
// Système PaLM 
// ** Summary : Basic constraints and handling mechanisms
// Part 1 : Complete all-diff (Régin implementation ...)
// Part 2 : Permutation constraint (dual representation of variables and values)
//              Permutation(x,y) <=> (x_i = j <=> y_j = i)
// Part 3 : GCC constraint
// Part 4 : GCCVar constraint
// Part 5 : Occur (nb of occurrence of a value (possibly an IntVar) in a list of vars
//			a tool for atleast, atmost, ...
// Part 6 : Element (correspondance between variables and indices in a list)
// 
// *************************************************************
// * Part 1 : ALLDIFFERENT constraint (Régin implementation)   *
// *************************************************************
// A PaLM version of the choco CompleteAllDiff
/* The c++ function for: self_print(c:PalmCompleteAllDiff) [] */
OID  claire_self_print_PalmCompleteAllDiff_palm(PalmCompleteAllDiff *c)
{ GC_BIND;
  princ_string("e-allDifferent(");
  { OID  g0087UU;
    { { list * V_CL0088;{ bag *v_list; OID v_val;
          OID x,CLcount;
          v_list = GC_OBJECT(list,c->vars);
           V_CL0088 = v_list->clone();
          for (CLcount= 1; CLcount <= v_list->length; CLcount++)
          { x = (*(v_list))[CLcount];
            v_val = x;
            
            (*((list *) V_CL0088))[CLcount] = v_val;} 
          } 
        
        g0087UU=_oid_(V_CL0088);} 
      GC_OID(g0087UU);} 
    print_any(g0087UU);
    } 
  { OID Result = 0;
    princ_string(")");
    GC_UNBIND; return (Result);} 
  } 


// API entry point: creating the constraint (before posting it)
/* The c++ function for: e-allDifferent(l1:list[PalmIntVar]) [] */
PalmCompleteAllDiff * claire_e_dashallDifferent_list(list *l1)
{ return (claire_e_dashcompleteAllDiff_list(l1));} 


/* The c++ function for: e-completeAllDiff(l1:list[PalmIntVar]) [] */
PalmCompleteAllDiff * claire_e_dashcompleteAllDiff_list(list *l1)
{ GC_BIND;
  { PalmCompleteAllDiff *Result ;
    { int  n = l1->length;
      PalmCompleteAllDiff * c;
      { { PalmCompleteAllDiff * _CL_obj = ((PalmCompleteAllDiff *) GC_OBJECT(PalmCompleteAllDiff,new_object_class(palm._PalmCompleteAllDiff)));
          c = _CL_obj;
          } 
        GC_OBJECT(PalmCompleteAllDiff,c);} 
      { ITERATE(v);
        for (START(l1); NEXT(v);)
        { (c->minValue = claire_min_integer2(c->minValue,choco.getInf->fcall(((int) OBJECT(ClaireObject,v)))));
          (c->maxValue = claire_max_integer2(c->maxValue,choco.getSup->fcall(((int) OBJECT(ClaireObject,v)))));
          } 
        } 
      (c->vars = ((list *) check_in_bag(copy_bag(l1),Kernel._list,choco._IntVar)));
      (c->nbVars = c->vars->length);
      (c->indices = make_list_integer2(c->nbVars,Kernel._integer,0));
      (c->nbLeftVertices = n);
      (c->nbRightVertices = ((c->maxValue-c->minValue)+1));
      choco_closeAssignmentConstraint_AbstractBipartiteGraph(c);
      { AbstractConstraint * g0089; 
        OID  g0090;
        g0089 = c;
        { PalmInfoConstraint * _CL_obj = ((PalmInfoConstraint *) GC_OBJECT(PalmInfoConstraint,new_object_class(palm._PalmInfoConstraint)));
          g0090 = _oid_(_CL_obj);
          } 
        (g0089->hook = g0090);} 
      Result = c;
      } 
    GC_UNBIND; return (Result);} 
  } 


// the event generated by the flow algorithm: discovering that an edge is no longer valid,
// and posting this event to all constraints but the current one
// (since we are already achieving consistency in one single loop)
/* The c++ function for: choco/deleteEdgeAndPublish(c:PalmCompleteAllDiff,i:integer,j:integer) [] */
void  choco_deleteEdgeAndPublish_PalmCompleteAllDiff(PalmCompleteAllDiff *c,int i,int j)
{ GC_BIND;
  ;if (j == ((OID *) c->refMatch)[i])
   { STOREI(c->refMatch[i],0);
    STOREI(c->refInverseMatch[j],0);
    STOREI(c->matchingSize,(c->matchingSize-1));
    } 
  { Explanation * expl;
    { { Explanation * _CL_obj = ((Explanation *) GC_OBJECT(Explanation,new_object_class(palm._Explanation)));
        expl = _CL_obj;
        } 
      GC_OBJECT(Explanation,expl);} 
    int  n1 = c->nbLeftVertices;
    int  n2 = c->nbRightVertices;
    int  compi = ((OID *) c->component)[i];
    int  compj = ((OID *) c->component)[(j+n1)];
    int  comps = ((OID *) c->component)[c->source];
    palm_self_explain_AbstractConstraint(c,expl);
    if ((OBJECT(ClaireBoolean,palm.ALLDIFF_PRECISE_EXPLANATIONS->value)) == CTRUE)
     { { int  i2 = 1;
        int  g0091 = n1;
        { OID gc_local;
          while ((i2 <= g0091))
          { GC_LOOP;
            { int  compi2 = ((OID *) c->component)[i2];
              if (claire_read_BoolMatrix2D(GC_OBJECT(BoolMatrix2D,c->componentOrder),compi,compi2) == CTRUE)
               { int  j2 = 1;
                int  g0092 = n2;
                { OID gc_local;
                  while ((j2 <= g0092))
                  { GC_LOOP;
                    { int  compj2 = ((OID *) c->component)[(j2+n1)];
                      if (claire_read_BoolMatrix2D(GC_OBJECT(BoolMatrix2D,c->componentOrder),compj2,compj) == CTRUE)
                       palm_self_explain_PalmIntVar2(OBJECT(PalmIntVar,(*(c->vars))[i2]),3,((j2+c->minValue)-1),expl);
                      } 
                    ++j2;
                    GC_UNLOOP;} 
                  } 
                } 
              } 
            ++i2;
            GC_UNLOOP;} 
          } 
        } 
      if (claire_read_BoolMatrix2D(GC_OBJECT(BoolMatrix2D,c->componentOrder),comps,compj) == CTRUE)
       { int  j2 = 1;
        int  g0093 = n2;
        { OID gc_local;
          while ((j2 <= g0093))
          { GC_LOOP;
            { int  compj2 = ((OID *) c->component)[(j2+n1)];
              int  i2 = ((OID *) c->refInverseMatch)[j2];
              if ((i2 != 0) && 
                  (claire_read_BoolMatrix2D(GC_OBJECT(BoolMatrix2D,c->componentOrder),compi,compj2) == CTRUE))
               { int  k = 1;
                int  g0094 = n2;
                { OID gc_local;
                  while ((k <= g0094))
                  { // HOHO, GC_LOOP not needed !
                    { int  compk = ((OID *) c->component)[(k+n1)];
                      if (compk != compj2)
                       palm_self_explain_PalmIntVar2(OBJECT(PalmIntVar,(*(c->vars))[i2]),3,((k+c->minValue)-1),expl);
                      } 
                    ++k;
                    } 
                  } 
                } 
              } 
            ++j2;
            GC_UNLOOP;} 
          } 
        } 
      if (claire_read_BoolMatrix2D(GC_OBJECT(BoolMatrix2D,c->componentOrder),compi,comps) == CTRUE)
       { int  j2 = 1;
        int  g0095 = n2;
        { OID gc_local;
          while ((j2 <= g0095))
          { GC_LOOP;
            { int  compj2 = ((OID *) c->component)[(j2+n1)];
              int  i2 = ((OID *) c->refInverseMatch)[j2];
              if ((i2 == 0) && 
                  (claire_read_BoolMatrix2D(GC_OBJECT(BoolMatrix2D,c->componentOrder),compj2,compj) == CTRUE))
               { int  k = 1;
                int  g0096 = n1;
                { OID gc_local;
                  while ((k <= g0096))
                  { // HOHO, GC_LOOP not needed !
                    { int  compk = ((OID *) c->component)[k];
                      if (compk == compj2)
                       palm_self_explain_PalmIntVar1(OBJECT(PalmIntVar,(*(c->vars))[k]),4,expl);
                      } 
                    ++k;
                    } 
                  } 
                } 
              } 
            ++j2;
            GC_UNLOOP;} 
          } 
        } 
      } 
    else { OID gc_local;
        ITERATE(v);
        bag *v_support;
        v_support = GC_OBJECT(list,c->vars);
        for (START(v_support); NEXT(v);)
        { GC_LOOP;
          palm_self_explain_PalmIntVar1(OBJECT(PalmIntVar,v),4,expl);
          GC_UNLOOP;} 
        } 
      (*choco.removeVal)((*(c->vars))[i],
      ((j+c->minValue)-1),
      (*(c->indices))[i],
      _oid_(expl));
    } 
  GC_UNBIND;} 


/* The c++ function for: updateDataStructuresOnConstraint(c:PalmCompleteAllDiff,idx:integer,way:{1, 2, 3, 4},val:integer,unused:integer) [] */
void  palm_updateDataStructuresOnConstraint_PalmCompleteAllDiff_palm(PalmCompleteAllDiff *c,int idx,int way,int val,int unused)
{ if (((val-c->minValue)+1) == ((OID *) c->refMatch)[idx])
   { STOREI(c->refMatch[idx],0);
    STOREI(c->refInverseMatch[((val-c->minValue)+1)],0);
    STOREI(c->matchingSize,(c->matchingSize-1));
    } 
  choco_constAwake_AbstractConstraint(c,CFALSE);
  } 


/* The c++ function for: updateDataStructuresOnRestoreConstraint(c:PalmCompleteAllDiff,idx:integer,way:{1, 2, 3, 4},val:integer,unused:integer) [] */
void  palm_updateDataStructuresOnRestoreConstraint_PalmCompleteAllDiff_palm(PalmCompleteAllDiff *c,int idx,int way,int val,int unused)
{ { int  n1 = c->nbLeftVertices;
    if ((c->matchingSize < n1) || 
        (((OID *) c->component)[idx] != ((OID *) c->component)[(((val-c->minValue)+1)+n1)]))
     choco_constAwake_AbstractConstraint(c,CFALSE);
    } 
  } 


// propagation functions: reacting to events
/* The c++ function for: choco/awakeOnRem(c:PalmCompleteAllDiff,idx:integer,val:integer) [] */
void  choco_awakeOnRem_PalmCompleteAllDiff(PalmCompleteAllDiff *c,int idx,int val)
{ ;} 


/* The c++ function for: awakeOnRestoreVal(c:PalmCompleteAllDiff,idx:integer,val:integer) [] */
void  palm_awakeOnRestoreVal_PalmCompleteAllDiff(PalmCompleteAllDiff *c,int idx,int val)
{ ;} 


// no specific initial propagation (awake does the same job as propagate)
/* The c++ function for: choco/awake(c:PalmCompleteAllDiff) [] */
void  choco_awake_PalmCompleteAllDiff_palm(PalmCompleteAllDiff *c)
{ choco_propagate_AbstractBipartiteGraph(c);
  ;} 


/* The c++ function for: checkPalm(ct:PalmCompleteAllDiff) [] */
ClaireBoolean * palm_checkPalm_PalmCompleteAllDiff(PalmCompleteAllDiff *ct)
{ return (CTRUE);} 


// claire3 port register no longer used
// *************************************************************
// * Part 2 : PERMUTATION constraint                           *
// *************************************************************
// the constraint uses two lists of integer valued variables and models
// a permutation (and the inverse permutation) over (1 .. n)
/* The c++ function for: self_print(c:PalmPermutation) [] */
OID  claire_self_print_PalmPermutation_palm(PalmPermutation *c)
{ GC_BIND;
  princ_string("e-permutation(");
  { OID  g0099UU;
    { list * V_CL0100;{ list * i_bag = list::empty(Kernel.emptySet);
        { int  i = 1;
          int  g0097 = c->nbLeftVertices;
          { OID gc_local;
            while ((i <= g0097))
            { // HOHO, GC_LOOP not needed !
              i_bag->addFast((*(c->vars))[i]);
              ++i;
              } 
            } 
          } 
        V_CL0100 = GC_OBJECT(list,i_bag);
        } 
      
      g0099UU=_oid_(V_CL0100);} 
    print_any(g0099UU);
    } 
  princ_string(",");
  { OID  g0101UU;
    { list * V_CL0102;{ list * i_bag = list::empty(Kernel.emptySet);
        { int  i = 1;
          int  g0098 = c->nbRightVertices;
          { OID gc_local;
            while ((i <= g0098))
            { // HOHO, GC_LOOP not needed !
              i_bag->addFast((*(c->vars))[(i+c->nbLeftVertices)]);
              ++i;
              } 
            } 
          } 
        V_CL0102 = GC_OBJECT(list,i_bag);
        } 
      
      g0101UU=_oid_(V_CL0102);} 
    print_any(g0101UU);
    } 
  { OID Result = 0;
    princ_string(")");
    GC_UNBIND; return (Result);} 
  } 


// API entry point: creating the constraint (before posting it)
/* The c++ function for: e-permutation(l1:list[PalmIntVar],l2:list[PalmIntVar]) [] */
PalmPermutation * claire_e_dashpermutation_list(list *l1,list *l2)
{ GC_BIND;
  { PalmPermutation *Result ;
    { PalmPermutation * c;
      { { PalmPermutation * _CL_obj = ((PalmPermutation *) GC_OBJECT(PalmPermutation,new_object_class(palm._PalmPermutation)));
          c = _CL_obj;
          } 
        GC_OBJECT(PalmPermutation,c);} 
      int  n = l1->length;
      { LargeIntConstraint * g0103; 
        list * g0104;
        g0103 = c;
        { list * g0105UU;
          { { bag *v_list; OID v_val;
              OID v,CLcount;
              v_list = l1;
               g0105UU = v_list->clone(choco._IntVar);
              for (CLcount= 1; CLcount <= v_list->length; CLcount++)
              { v = (*(v_list))[CLcount];
                v_val = v;
                
                (*((list *) g0105UU))[CLcount] = v_val;} 
              } 
            GC_OBJECT(list,g0105UU);} 
          list * g0106UU;
          { { bag *v_list; OID v_val;
              OID v,CLcount;
              v_list = l2;
               g0106UU = v_list->clone(choco._IntVar);
              for (CLcount= 1; CLcount <= v_list->length; CLcount++)
              { v = (*(v_list))[CLcount];
                v_val = v;
                
                (*((list *) g0106UU))[CLcount] = v_val;} 
              } 
            GC_OBJECT(list,g0106UU);} 
          g0104 = append_list(g0105UU,g0106UU);
          } 
        (g0103->vars = g0104);} 
      (c->nbVars = c->vars->length);
      (c->indices = make_list_integer2(c->nbVars,Kernel._integer,0));
      (c->nbLeftVertices = n);
      (c->nbRightVertices = n);
      (c->minValue = 1);
      (c->maxValue = n);
      choco_closeAssignmentConstraint_AbstractBipartiteGraph(c);
      { AbstractConstraint * g0107; 
        OID  g0108;
        g0107 = c;
        { PalmInfoConstraint * _CL_obj = ((PalmInfoConstraint *) GC_OBJECT(PalmInfoConstraint,new_object_class(palm._PalmInfoConstraint)));
          g0108 = _oid_(_CL_obj);
          } 
        (g0107->hook = g0108);} 
      Result = c;
      } 
    GC_UNBIND; return (Result);} 
  } 


/* The c++ function for: choco/deleteEdgeAndPublish(c:PalmPermutation,i:integer,j:integer) [] */
void  choco_deleteEdgeAndPublish_PalmPermutation(PalmPermutation *c,int i,int j)
{ GC_BIND;
  ;{ int  n1 = c->nbLeftVertices;
    int  n2 = c->nbRightVertices;
    int  compi = ((OID *) c->component)[i];
    int  compj = ((OID *) c->component)[(j+n1)];
    if (j == ((OID *) c->refMatch)[i])
     { STOREI(c->refMatch[i],0);
      STOREI(c->refInverseMatch[j],0);
      STOREI(c->matchingSize,(c->matchingSize-1));
      } 
    { Explanation * expl;
      { { Explanation * _CL_obj = ((Explanation *) GC_OBJECT(Explanation,new_object_class(palm._Explanation)));
          expl = _CL_obj;
          } 
        GC_OBJECT(Explanation,expl);} 
      palm_self_explain_AbstractConstraint(c,expl);
      { OID gc_local;
        ITERATE(v);
        bag *v_support;
        v_support = GC_OBJECT(list,c->vars);
        for (START(v_support); NEXT(v);)
        { GC_LOOP;
          palm_self_explain_PalmIntVar1(OBJECT(PalmIntVar,v),4,expl);
          GC_UNLOOP;} 
        } 
      (*choco.removeVal)((*(c->vars))[i],
        j,
        (*(c->indices))[i],
        GC_OID(_oid_(palm_clone_Explanation(expl))));
      (*choco.removeVal)((*(c->vars))[(n1+j)],
        i,
        (*(c->indices))[(n1+j)],
        GC_OID(_oid_(palm_clone_Explanation(expl))));
      } 
    } 
  GC_UNBIND;} 


/* The c++ function for: publishDeletion(c:PalmPermutation,i:integer,j:integer,fromLeft:boolean) [] */
OID  palm_publishDeletion_PalmPermutation(PalmPermutation *c,int i,int j,ClaireBoolean *fromLeft)
{ GC_BIND;
  { OID Result = 0;
    { int  n1 = c->nbLeftVertices;
      int  n2 = c->nbRightVertices;
      if (fromLeft == CTRUE)
       Result = (*choco.removeVal)((*(c->vars))[(j+n1)],
        i,
        (*(c->indices))[(j+n1)],
        GC_OID((*palm.becauseOf)(_oid_(c),
          _oid_(tuple::alloc(3,(*(c->vars))[i],
            3,
            j)))));
      else Result = (*choco.removeVal)((*(c->vars))[i],
          j,
          (*(c->indices))[i],
          GC_OID((*palm.becauseOf)(_oid_(c),
            _oid_(tuple::alloc(3,(*(c->vars))[(j+n1)],
              3,
              i)))));
        } 
    GC_UNBIND; return (Result);} 
  } 


/* The c++ function for: updateDataStructuresOnConstraint(c:PalmPermutation,idx:integer,way:{1, 2, 3, 4},val:integer,unused:integer) [] */
void  palm_updateDataStructuresOnConstraint_PalmPermutation_palm(PalmPermutation *c,int idx,int way,int val,int unused)
{ { int  n = c->nbLeftVertices;
    if (idx <= n)
     { if (val == ((OID *) c->refMatch)[idx])
       { STOREI(c->refMatch[idx],0);
        STOREI(c->refInverseMatch[val],0);
        STOREI(c->matchingSize,(c->matchingSize-1));
        } 
      } 
    else { idx= (idx-n);
        if (idx == ((OID *) c->refMatch)[val])
         { STOREI(c->refMatch[val],0);
          STOREI(c->refInverseMatch[idx],0);
          STOREI(c->matchingSize,(c->matchingSize-1));
          } 
        } 
      } 
  choco_constAwake_AbstractConstraint(c,CFALSE);
  } 


/* The c++ function for: updateDataStructuresOnRestoreConstraint(c:PalmPermutation,idx:integer,way:{1, 2, 3, 4},val:integer,unused:integer) [] */
void  palm_updateDataStructuresOnRestoreConstraint_PalmPermutation_palm(PalmPermutation *c,int idx,int way,int val,int unused)
{ { int  n = c->nbLeftVertices;
    if (idx <= n)
     { if ((c->matchingSize < n) || 
          (((OID *) c->component)[idx] != ((OID *) c->component)[(val+n)]))
       choco_constAwake_AbstractConstraint(c,CFALSE);
      } 
    else if ((c->matchingSize < n) || 
        (((OID *) c->component)[val] != ((OID *) c->component)[idx]))
     choco_constAwake_AbstractConstraint(c,CFALSE);
    } 
  } 


// propagation functions: reacting to events
/* The c++ function for: choco/awakeOnRem(c:PalmPermutation,idx:integer,val:integer) [] */
void  choco_awakeOnRem_PalmPermutation(PalmPermutation *c,int idx,int val)
{ { int  n = c->nbLeftVertices;
    if (idx <= c->nbLeftVertices)
     palm_publishDeletion_PalmPermutation(c,idx,val,CTRUE);
    else { idx= (idx-n);
        palm_publishDeletion_PalmPermutation(c,val,idx,CFALSE);
        } 
      } 
  } 


/* The c++ function for: awakeOnRestoreVal(c:PalmPermutation,idx:integer,val:integer) [] */
void  palm_awakeOnRestoreVal_PalmPermutation(PalmPermutation *c,int idx,int val)
{ ;} 


// performing the initial propagation
/* The c++ function for: choco/awake(c:PalmPermutation) [] */
void  choco_awake_PalmPermutation_palm(PalmPermutation *c)
{ GC_BIND;
  { int  n = c->nbLeftVertices;
    Explanation * expl;
    { { Explanation * _CL_obj = ((Explanation *) GC_OBJECT(Explanation,new_object_class(palm._Explanation)));
        expl = _CL_obj;
        } 
      GC_OBJECT(Explanation,expl);} 
    palm_self_explain_AbstractConstraint(c,expl);
    { int  i = 1;
      int  g0109 = n;
      { OID gc_local;
        while ((i <= g0109))
        { GC_LOOP;
          (*choco.updateInf)((*(c->vars))[i],
            1,
            (*(c->indices))[i],
            GC_OID(_oid_(palm_clone_Explanation(expl))));
          (*choco.updateSup)((*(c->vars))[i],
            n,
            (*(c->indices))[i],
            GC_OID(_oid_(palm_clone_Explanation(expl))));
          ++i;
          GC_UNLOOP;} 
        } 
      } 
    { int  j = 1;
      int  g0110 = n;
      { OID gc_local;
        while ((j <= g0110))
        { GC_LOOP;
          (*choco.updateInf)((*(c->vars))[(j+n)],
            1,
            (*(c->indices))[(j+n)],
            GC_OID(_oid_(palm_clone_Explanation(expl))));
          (*choco.updateSup)((*(c->vars))[(j+n)],
            n,
            (*(c->indices))[(j+n)],
            GC_OID(_oid_(palm_clone_Explanation(expl))));
          ++j;
          GC_UNLOOP;} 
        } 
      } 
    { int  i = 1;
      int  g0111 = n;
      { OID gc_local;
        while ((i <= g0111))
        { GC_LOOP;
          { int  j = 1;
            int  g0112 = n;
            { OID gc_local;
              while ((j <= g0112))
              { GC_LOOP;
                if (not_any((*choco.canBeInstantiatedTo)((*(c->vars))[i],
                  j)) == CTRUE)
                 (*choco.removeVal)((*(c->vars))[(j+n)],
                  i,
                  (*(c->indices))[(j+n)],
                  GC_OID((*palm.becauseOf)(_oid_(c),
                    _oid_(tuple::alloc(3,(*(c->vars))[i],
                      3,
                      j)))));
                if (not_any((*choco.canBeInstantiatedTo)((*(c->vars))[(j+n)],
                  i)) == CTRUE)
                 (*choco.removeVal)((*(c->vars))[i],
                  j,
                  (*(c->indices))[i],
                  GC_OID((*palm.becauseOf)(_oid_(c),
                    _oid_(tuple::alloc(3,(*(c->vars))[(j+n)],
                      3,
                      i)))));
                ++j;
                GC_UNLOOP;} 
              } 
            } 
          ++i;
          GC_UNLOOP;} 
        } 
      } 
    choco_propagate_AbstractBipartiteGraph(c);
    } 
  ;GC_UNBIND;} 


/* The c++ function for: checkPalm(ct:PalmPermutation) [] */
ClaireBoolean * palm_checkPalm_PalmPermutation(PalmPermutation *ct)
{ return (CTRUE);} 


// claire3 port register no longer used
// *************************************************************
// * Part 3 : GCC constraint                                   *
// *************************************************************
// a very simple version of the cardinality constraint 
/* The c++ function for: self_print(c:PalmGlobalCardinality) [] */
OID  claire_self_print_PalmGlobalCardinality_palm(PalmGlobalCardinality *c)
{ GC_BIND;
  princ_string("e-gcc(");
  print_any(GC_OID(_oid_(c->vars)));
  princ_string(",[(");
  print_any(((OID *) c->minFlow)[1]);
  princ_string("..");
  print_any(((OID *) c->maxFlow)[1]);
  princ_string(")");
  { int  i = 2;
    int  g0113 = c->minFlow[0];
    { OID gc_local;
      while ((i <= g0113))
      { // HOHO, GC_LOOP not needed !
        princ_string(",(");
        print_any(((OID *) c->minFlow)[i]);
        princ_string("..");
        print_any(((OID *) c->maxFlow)[i]);
        princ_string(")");
        ++i;
        } 
      } 
    } 
  { OID Result = 0;
    princ_string("])");
    GC_UNBIND; return (Result);} 
  } 


// API entry point: creating the constraint (before posting it)
/* The c++ function for: e-gcc(l1:list[PalmIntVar],l2:list[Interval]) [] */
PalmGlobalCardinality * palm_e_dashgcc_list1(list *l1,list *l2)
{ return (palm_e_dashgcc_list2(l1,1,l2->length,l2));} 


/* The c++ function for: e-gcc(l1:list[PalmIntVar],val1:integer,val2:integer,l2:list[Interval]) [] */
PalmGlobalCardinality * palm_e_dashgcc_list2(list *l1,int val1,int val2,list *l2)
{ GC_BIND;
  { PalmGlobalCardinality *Result ;
    { PalmGlobalCardinality * c;
      { { PalmGlobalCardinality * _CL_obj = ((PalmGlobalCardinality *) GC_OBJECT(PalmGlobalCardinality,new_object_class(palm._PalmGlobalCardinality)));
          c = _CL_obj;
          } 
        GC_OBJECT(PalmGlobalCardinality,c);} 
      (c->vars = ((list *) check_in_bag(copy_bag(l1),Kernel._list,choco._IntVar)));
      (c->nbVars = c->vars->length);
      (c->indices = make_list_integer2(c->nbVars,Kernel._integer,0));
      (c->minValue = val1);
      (c->maxValue = val2);
      (c->nbRightVertices = ((val2-val1)+1));
      (c->nbLeftVertices = l1->length);
      (c->minFlow = make_array_integer(l2->length,Kernel._integer,0));
      (c->maxFlow = make_array_integer(l2->length,Kernel._integer,0));
      (c->flow = make_array_integer(l2->length,Kernel._integer,0));
      { int  i = 1;
        int  g0114 = l2->length;
        { OID gc_local;
          while ((i <= g0114))
          { // HOHO, GC_LOOP not needed !
            (((OID *) c->minFlow)[i] = OBJECT(Interval,(*(l2))[i])->arg1);
            (((OID *) c->maxFlow)[i] = OBJECT(Interval,(*(l2))[i])->arg2);
            ++i;
            } 
          } 
        } 
      choco_closeAssignmentConstraint_AbstractBipartiteGraph(c);
      { AbstractConstraint * g0115; 
        OID  g0116;
        g0115 = c;
        { PalmInfoConstraint * _CL_obj = ((PalmInfoConstraint *) GC_OBJECT(PalmInfoConstraint,new_object_class(palm._PalmInfoConstraint)));
          g0116 = _oid_(_CL_obj);
          } 
        (g0115->hook = g0116);} 
      Result = c;
      } 
    GC_UNBIND; return (Result);} 
  } 


// The next two functions implement the main event:
// when an edge is definitely removed from the bipartite assignment graph.
/* The c++ function for: choco/deleteEdgeAndPublish(c:PalmGlobalCardinality,i:integer,j:integer) [] */
void  choco_deleteEdgeAndPublish_PalmGlobalCardinality(PalmGlobalCardinality *c,int i,int j)
{ GC_BIND;
  ;if (j == ((OID *) c->refMatch)[i])
   { STOREI(c->refMatch[i],0);
    STOREI(c->matchingSize,(c->matchingSize-1));
    STOREI(c->flow[j],((((OID *) c->flow)[j])-1));
    } 
  { Explanation * expl;
    { { Explanation * _CL_obj = ((Explanation *) GC_OBJECT(Explanation,new_object_class(palm._Explanation)));
        expl = _CL_obj;
        } 
      GC_OBJECT(Explanation,expl);} 
    int  n1 = c->nbLeftVertices;
    int  n2 = c->nbRightVertices;
    int  compi = ((OID *) c->component)[i];
    int  compj = ((OID *) c->component)[(j+n1)];
    palm_self_explain_AbstractConstraint(c,expl);
    { int  i2 = 1;
      int  g0117 = n1;
      { OID gc_local;
        while ((i2 <= g0117))
        { GC_LOOP;
          { int  compi2 = ((OID *) c->component)[i2];
            if ((compi != compi2) && 
                (claire_read_BoolMatrix2D(GC_OBJECT(BoolMatrix2D,c->componentOrder),compi,compi2) == CTRUE))
             { int  j2 = 1;
              int  g0118 = n2;
              { OID gc_local;
                while ((j2 <= g0118))
                { GC_LOOP;
                  { int  compj2 = ((OID *) c->component)[(j2+n1)];
                    if (claire_read_BoolMatrix2D(GC_OBJECT(BoolMatrix2D,c->componentOrder),compj2,compj) == CTRUE)
                     palm_self_explain_PalmIntVar2(OBJECT(PalmIntVar,(*(c->vars))[i2]),3,((j2+c->minValue)-1),expl);
                    } 
                  ++j2;
                  GC_UNLOOP;} 
                } 
              } 
            } 
          ++i2;
          GC_UNLOOP;} 
        } 
      } 
    (*choco.removeVal)((*(c->vars))[i],
      ((j+c->minValue)-1),
      (*(c->indices))[i],
      _oid_(expl));
    } 
  GC_UNBIND;} 


/* The c++ function for: updateDataStructuresOnConstraint(c:PalmGlobalCardinality,idx:integer,way:{1, 2, 3, 4},val:integer,unused:integer) [] */
void  palm_updateDataStructuresOnConstraint_PalmGlobalCardinality_palm(PalmGlobalCardinality *c,int idx,int way,int val,int unused)
{ if (((val-c->minValue)+1) == ((OID *) c->refMatch)[idx])
   { STOREI(c->refMatch[idx],0);
    STOREI(c->matchingSize,(c->matchingSize-1));
    STOREI(c->flow[((val-c->minValue)+1)],((((OID *) c->flow)[((val-c->minValue)+1)])-1));
    } 
  choco_constAwake_AbstractConstraint(c,CFALSE);
  } 


/* The c++ function for: updateDataStructuresOnRestoreConstraint(c:PalmGlobalCardinality,idx:integer,way:{1, 2, 3, 4},val:integer,unused:integer) [] */
void  palm_updateDataStructuresOnRestoreConstraint_PalmGlobalCardinality_palm(PalmGlobalCardinality *c,int idx,int way,int val,int unused)
{ { int  n1 = c->nbLeftVertices;
    if ((c->matchingSize < n1) || 
        (((OID *) c->component)[idx] != ((OID *) c->component)[(((val-c->minValue)+1)+n1)]))
     choco_constAwake_AbstractConstraint(c,CFALSE);
    } 
  } 


/* The c++ function for: choco/awakeOnRem(c:PalmGlobalCardinality,idx:integer,val:integer) [] */
void  choco_awakeOnRem_PalmGlobalCardinality(PalmGlobalCardinality *c,int idx,int val)
{ ;} 


/* The c++ function for: awakeOnRestoreVal(c:PalmGlobalCardinality,idx:integer,val:integer) [] */
void  palm_awakeOnRestoreVal_PalmGlobalCardinality(PalmGlobalCardinality *c,int idx,int val)
{ ;} 


/* The c++ function for: choco/awake(c:PalmGlobalCardinality) [] */
void  choco_awake_PalmGlobalCardinality_palm(PalmGlobalCardinality *c)
{ GC_BIND;
  { int  i = 1;
    int  g0119 = c->nbLeftVertices;
    { OID gc_local;
      while ((i <= g0119))
      { GC_LOOP;
        (*choco.updateInf)((*(c->vars))[i],
          c->minValue,
          (*(c->indices))[i],
          GC_OID((*palm.becauseOf)(_oid_(c))));
        (*choco.updateSup)((*(c->vars))[i],
          c->maxValue,
          (*(c->indices))[i],
          GC_OID((*palm.becauseOf)(_oid_(c))));
        ++i;
        GC_UNLOOP;} 
      } 
    } 
  _void_(choco.propagate->fcall(((int) c)));
  ;GC_UNBIND;} 


/* The c++ function for: checkPalm(ct:PalmGlobalCardinality) [] */
ClaireBoolean * palm_checkPalm_PalmGlobalCardinality(PalmGlobalCardinality *ct)
{ return (CTRUE);} 


// claire3 port register no longer used
// *************************************************************
// * Part 4 : GCCVAR constraint                                *
// *************************************************************
// Il faut sûrement réécrire augmentFlow car il ne faut pas qu'une 
// contradiction choco soit levée !!! 
// a less simple version of the GCC constraint
/* The c++ function for: self_print(c:PalmGlobalCardinalityVar) [] */
OID  claire_self_print_PalmGlobalCardinalityVar_palm(PalmGlobalCardinalityVar *c)
{ GC_BIND;
  princ_string("e-gcc(");
  { OID  g0122UU;
    { list * V_CL0123;{ list * i_bag = list::empty(Kernel.emptySet);
        { int  i = 1;
          int  g0120 = c->nbLeftVertices;
          { OID gc_local;
            while ((i <= g0120))
            { // HOHO, GC_LOOP not needed !
              i_bag->addFast((*(c->vars))[i]);
              ++i;
              } 
            } 
          } 
        V_CL0123 = GC_OBJECT(list,i_bag);
        } 
      
      g0122UU=_oid_(V_CL0123);} 
    print_any(g0122UU);
    } 
  princ_string(",");
  { OID  g0124UU;
    { list * V_CL0125;{ list * i_bag = list::empty(Kernel.emptySet);
        { int  i = 1;
          int  g0121 = c->nbRightVertices;
          { OID gc_local;
            while ((i <= g0121))
            { // HOHO, GC_LOOP not needed !
              i_bag->addFast((*(c->vars))[(i+c->nbLeftVertices)]);
              ++i;
              } 
            } 
          } 
        V_CL0125 = GC_OBJECT(list,i_bag);
        } 
      
      g0124UU=_oid_(V_CL0125);} 
    print_any(g0124UU);
    } 
  { OID Result = 0;
    princ_string(")");
    GC_UNBIND; return (Result);} 
  } 


// API entry point: creating the constraint (before posting it)
/* The c++ function for: e-gcc(l1:list[PalmIntVar],l2:list[PalmIntVar]) [] */
PalmGlobalCardinalityVar * palm_e_dashgcc_list3(list *l1,list *l2)
{ return (palm_e_dashgcc_list4(l1,1,l2->length,l2));} 


/* The c++ function for: e-gcc(l1:list[PalmIntVar],val1:integer,val2:integer,l2:list[PalmIntVar]) [] */
PalmGlobalCardinalityVar * palm_e_dashgcc_list4(list *l1,int val1,int val2,list *l2)
{ GC_BIND;
  { PalmGlobalCardinalityVar *Result ;
    { PalmGlobalCardinalityVar * c;
      { { PalmGlobalCardinalityVar * _CL_obj = ((PalmGlobalCardinalityVar *) GC_OBJECT(PalmGlobalCardinalityVar,new_object_class(palm._PalmGlobalCardinalityVar)));
          c = _CL_obj;
          } 
        GC_OBJECT(PalmGlobalCardinalityVar,c);} 
      (c->vars = append_list(((list *) copy_bag(l1)),((list *) copy_bag(l2))));
      (c->intervals = ((list *) copy_bag(l2)));
      (c->nbVars = c->vars->length);
      (c->indices = make_list_integer2(c->nbVars,Kernel._integer,0));
      (c->minValue = val1);
      (c->maxValue = val2);
      (c->nbRightVertices = ((val2-val1)+1));
      (c->nbLeftVertices = l1->length);
      (c->minFlow = make_array_integer(l2->length,Kernel._integer,0));
      (c->maxFlow = make_array_integer(l2->length,Kernel._integer,0));
      (c->flow = make_array_integer(l2->length,Kernel._integer,0));
      { int  i = 1;
        int  g0126 = l2->length;
        { OID gc_local;
          while ((i <= g0126))
          { // HOHO, GC_LOOP not needed !
            (((OID *) c->minFlow)[i] = choco.getInf->fcall(((int) OBJECT(ClaireObject,(*(l2))[i]))));
            (((OID *) c->maxFlow)[i] = choco.getSup->fcall(((int) OBJECT(ClaireObject,(*(l2))[i]))));
            ++i;
            } 
          } 
        } 
      choco_closeAssignmentConstraint_AbstractBipartiteGraph(c);
      { AbstractConstraint * g0127; 
        OID  g0128;
        g0127 = c;
        { PalmInfoConstraint * _CL_obj = ((PalmInfoConstraint *) GC_OBJECT(PalmInfoConstraint,new_object_class(palm._PalmInfoConstraint)));
          g0128 = _oid_(_CL_obj);
          } 
        (g0127->hook = g0128);} 
      Result = c;
      } 
    GC_UNBIND; return (Result);} 
  } 


/* The c++ function for: mustDiminishFlowFromSource(c:PalmGlobalCardinalityVar,j:integer) [] */
ClaireBoolean * palm_mustDiminishFlowFromSource_PalmGlobalCardinalityVar(PalmGlobalCardinalityVar *c,int j)
{ return (_sup_integer(((OID *) c->flow)[j],((OID *) c->maxFlow)[j]));} 


/* The c++ function for: updateDataStructuresOnConstraint(c:PalmGlobalCardinalityVar,idx:integer,way:{1, 2, 3, 4},val:integer,unused:integer) [] */
void  palm_updateDataStructuresOnConstraint_PalmGlobalCardinalityVar_palm(PalmGlobalCardinalityVar *c,int idx,int way,int val,int unused)
{ if (idx <= c->nbLeftVertices)
   { if (((val-c->minValue)+1) == ((OID *) c->refMatch)[idx])
     { STOREI(c->refMatch[idx],0);
      STOREI(c->matchingSize,(c->matchingSize-1));
      STOREI(c->flow[((val-c->minValue)+1)],((((OID *) c->flow)[((val-c->minValue)+1)])-1));
      } 
    choco_constAwake_AbstractConstraint(c,CFALSE);
    } 
  else { int  ridx = (idx-c->nbLeftVertices);
      if ((((OID *) c->minFlow)[ridx] < choco.getInf->fcall(((int) OBJECT(ClaireObject,(*(c->vars))[idx])))) || 
          (((OID *) c->maxFlow)[ridx] > choco.getSup->fcall(((int) OBJECT(ClaireObject,(*(c->vars))[idx])))))
       { (((OID *) c->minFlow)[ridx] = choco.getInf->fcall(((int) OBJECT(ClaireObject,(*(c->vars))[idx]))));
        (((OID *) c->maxFlow)[ridx] = choco.getSup->fcall(((int) OBJECT(ClaireObject,(*(c->vars))[idx]))));
        if (((OID *) c->flow)[ridx] < ((OID *) c->minFlow)[ridx])
         choco_constAwake_AbstractConstraint(c,CFALSE);
        else if (palm_mustDiminishFlowFromSource_PalmGlobalCardinalityVar(c,ridx) == CTRUE)
         { choco_closeAssignmentConstraint_AbstractBipartiteGraph(c);
          (c->flow = make_array_integer(c->intervals->length,Kernel._integer,0));
          choco_constAwake_AbstractConstraint(c,CFALSE);
          } 
        } 
      } 
    } 


/* The c++ function for: updateDataStructuresOnRestoreConstraint(c:PalmGlobalCardinalityVar,idx:integer,way:{1, 2, 3, 4},val:integer,unused:integer) [] */
void  palm_updateDataStructuresOnRestoreConstraint_PalmGlobalCardinalityVar_palm(PalmGlobalCardinalityVar *c,int idx,int way,int val,int unused)
{ { int  n1 = c->nbLeftVertices;
    if (idx <= n1)
     { if ((c->matchingSize < n1) || 
          (((OID *) c->component)[idx] != ((OID *) c->component)[(((val-c->minValue)+1)+n1)]))
       choco_constAwake_AbstractConstraint(c,CFALSE);
      } 
    else { int  ridx = (idx-n1);
        if ((((OID *) c->minFlow)[ridx] > choco.getInf->fcall(((int) OBJECT(ClaireObject,(*(c->vars))[idx])))) || 
            (((OID *) c->maxFlow)[ridx] < choco.getSup->fcall(((int) OBJECT(ClaireObject,(*(c->vars))[idx])))))
         { (((OID *) c->minFlow)[ridx] = choco.getInf->fcall(((int) OBJECT(ClaireObject,(*(c->vars))[idx]))));
          (((OID *) c->maxFlow)[ridx] = choco.getSup->fcall(((int) OBJECT(ClaireObject,(*(c->vars))[idx]))));
          choco_constAwake_AbstractConstraint(c,CFALSE);
          } 
        } 
      } 
  } 


/* The c++ function for: choco/awakeOnRem(c:PalmGlobalCardinalityVar,idx:integer,val:integer) [] */
void  choco_awakeOnRem_PalmGlobalCardinalityVar(PalmGlobalCardinalityVar *c,int idx,int val)
{ ;} 


/* The c++ function for: awakeOnRestoreVal(c:PalmGlobalCardinalityVar,idx:integer,val:integer) [] */
void  palm_awakeOnRestoreVal_PalmGlobalCardinalityVar(PalmGlobalCardinalityVar *c,int idx,int val)
{ ;} 


/* The c++ function for: choco/awake(c:PalmGlobalCardinalityVar) [] */
void  choco_awake_PalmGlobalCardinalityVar_palm(PalmGlobalCardinalityVar *c)
{ GC_BIND;
  { int  i = 1;
    int  g0129 = c->nbLeftVertices;
    { OID gc_local;
      while ((i <= g0129))
      { GC_LOOP;
        (*choco.updateInf)((*(c->vars))[i],
          c->minValue,
          (*(c->indices))[i],
          GC_OID((*palm.becauseOf)(_oid_(c))));
        (*choco.updateSup)((*(c->vars))[i],
          c->maxValue,
          (*(c->indices))[i],
          GC_OID((*palm.becauseOf)(_oid_(c))));
        ++i;
        GC_UNLOOP;} 
      } 
    } 
  choco_propagate_PalmGlobalCardinalityVar(c);
  ;GC_UNBIND;} 


/* The c++ function for: choco/propagate(c:PalmGlobalCardinalityVar) [] */
void  choco_propagate_PalmGlobalCardinalityVar(PalmGlobalCardinalityVar *c)
{ GC_RESERVE(1);  // HOHO v3.0.55 optim !
  palm_removeUselessEdges_PalmGlobalCardinality(c);
  { int  n1 = c->nbLeftVertices;
    int  source = c->nbVertices;
    int  csource = ((OID *) c->component)[source];
    Explanation * expl;
    { { Explanation * _CL_obj = ((Explanation *) GC_OBJECT(Explanation,new_object_class(palm._Explanation)));
        expl = _CL_obj;
        } 
      GC_OBJECT(Explanation,expl);} 
    palm_self_explain_AbstractConstraint(c,expl);
    { OID gc_local;
      ITERATE(v);
      bag *v_support;
      v_support = GC_OBJECT(list,c->vars);
      for (START(v_support); NEXT(v);)
      { GC_LOOP;
        palm_self_explain_PalmIntVar1(OBJECT(PalmIntVar,v),4,expl);
        GC_UNLOOP;} 
      } 
    { int  val = c->minValue;
      int  g0130 = c->maxValue;
      { OID gc_local;
        while ((val <= g0130))
        { GC_LOOP;
          if (((OID *) c->component)[(((val-c->minValue)+1)+n1)] != csource)
           { int  vassign = ((OID *) c->flow)[((val-c->minValue)+1)];
            IntVar * cvar = OBJECT(IntVar,(*(c->vars))[(((n1+val)-c->minValue)+1)]);
            int  cidx = (*(c->indices))[(((n1+val)-c->minValue)+1)];
            Explanation * expl;
            { { Explanation * _CL_obj = ((Explanation *) GC_OBJECT(Explanation,new_object_class(palm._Explanation)));
                expl = _CL_obj;
                } 
              GC_OBJECT(Explanation,expl);} 
            { OID gc_local;
              ITERATE(vi);
              bag *vi_support;
              vi_support = GC_OBJECT(list,OBJECT(bag,_oid_((ClaireObject *) choco.domainSequence->fcall(((int) OBJECT(ClaireObject,GC_OID((*choco.bucket)(_oid_(cvar)))))))));
              for (START(vi_support); NEXT(vi);)
              { GC_LOOP;
                if (vi != vassign)
                 (*choco.removeVal)(_oid_(cvar),
                  vi,
                  cidx,
                  GC_OID(_oid_(palm_clone_Explanation(expl))));
                GC_UNLOOP;} 
              } 
            } 
          ++val;
          GC_UNLOOP;} 
        } 
      } 
    } 
  GC_UNBIND;} 


/* The c++ function for: checkPalm(ct:PalmGlobalCardinalityVar) [] */
ClaireBoolean * palm_checkPalm_PalmGlobalCardinalityVar(PalmGlobalCardinalityVar *ct)
{ return (CTRUE);} 


// claire3 port register no longer used
// ***
// * common propagation tool                            
// ***
/* The c++ function for: ice/augmentFlow(c:PalmCompleteAllDiff) [] */
void  ice_augmentFlow_PalmCompleteAllDiff_palm(PalmCompleteAllDiff *c)
{ GC_BIND;
  { int  eopath = ice_findAlternatingPath_AbstractBipartiteMatching(c);
    int  n1 = c->nbLeftVertices;
    if (c->matchingSize < n1)
     ;{ OID gc_local;
      while ((eopath > 0))
      { // HOHO, GC_LOOP not needed !
        choco_augment_AbstractBipartiteMatching(c,eopath);
        eopath= ice_findAlternatingPath_AbstractBipartiteMatching(c);
        } 
      } 
    if (c->matchingSize < n1)
     { { Explanation * expl;
        { { Explanation * _CL_obj = ((Explanation *) GC_OBJECT(Explanation,new_object_class(palm._Explanation)));
            expl = _CL_obj;
            } 
          GC_OBJECT(Explanation,expl);} 
        palm_self_explain_AbstractConstraint(c,expl);
        { OID gc_local;
          ITERATE(v);
          bag *v_support;
          v_support = GC_OBJECT(list,c->vars);
          for (START(v_support); NEXT(v);)
          { GC_LOOP;
            palm_self_explain_PalmIntVar1(OBJECT(PalmIntVar,v),4,expl);
            GC_UNLOOP;} 
          } 
        palm_raisePalmFakeContradiction_PalmEngine(GC_OBJECT(PalmEngine,((PalmEngine *) choco_getProblem_AbstractConstraint(c)->propagationEngine)),expl);
        } 
      } 
    else { { int  g0131 = c->nbLeftVertices;
          int  g0132 = c->nbRightVertices;
          (ice.CHK->value= _oid_(c));
          ;} 
        } 
      } 
  GC_UNBIND;} 


/* The c++ function for: ice/augmentFlow(c:PalmPermutation) [] */
void  ice_augmentFlow_PalmPermutation_palm(PalmPermutation *c)
{ GC_BIND;
  { int  eopath = ice_findAlternatingPath_AbstractBipartiteMatching(c);
    int  n1 = c->nbLeftVertices;
    if (c->matchingSize < n1)
     ;{ OID gc_local;
      while ((eopath > 0))
      { // HOHO, GC_LOOP not needed !
        choco_augment_AbstractBipartiteMatching(c,eopath);
        eopath= ice_findAlternatingPath_AbstractBipartiteMatching(c);
        } 
      } 
    if (c->matchingSize < n1)
     { { Explanation * expl;
        { { Explanation * _CL_obj = ((Explanation *) GC_OBJECT(Explanation,new_object_class(palm._Explanation)));
            expl = _CL_obj;
            } 
          GC_OBJECT(Explanation,expl);} 
        palm_self_explain_AbstractConstraint(c,expl);
        { OID gc_local;
          ITERATE(v);
          bag *v_support;
          v_support = GC_OBJECT(list,c->vars);
          for (START(v_support); NEXT(v);)
          { GC_LOOP;
            palm_self_explain_PalmIntVar1(OBJECT(PalmIntVar,v),4,expl);
            GC_UNLOOP;} 
          } 
        palm_raisePalmFakeContradiction_PalmEngine(GC_OBJECT(PalmEngine,((PalmEngine *) choco_getProblem_AbstractConstraint(c)->propagationEngine)),expl);
        } 
      } 
    else { { int  g0135 = c->nbLeftVertices;
          int  g0136 = c->nbRightVertices;
          (ice.CHK->value= _oid_(c));
          ;} 
        } 
      } 
  GC_UNBIND;} 


/* The c++ function for: ice/augmentFlow(c:PalmGlobalCardinality) [] */
void  ice_augmentFlow_PalmGlobalCardinality_palm(PalmGlobalCardinality *c)
{ GC_BIND;
  { int  eopath = ice_findAlternatingPath_AbstractBipartiteFlow(c);
    int  n1 = c->nbLeftVertices;
    if (c->matchingSize < n1)
     ;{ OID gc_local;
      while ((eopath > 0))
      { // HOHO, GC_LOOP not needed !
        choco_augment_AbstractBipartiteFlow(c,eopath);
        eopath= ice_findAlternatingPath_AbstractBipartiteFlow(c);
        } 
      } 
    if (c->matchingSize < n1)
     { { Explanation * expl;
        { { Explanation * _CL_obj = ((Explanation *) GC_OBJECT(Explanation,new_object_class(palm._Explanation)));
            expl = _CL_obj;
            } 
          GC_OBJECT(Explanation,expl);} 
        palm_self_explain_AbstractConstraint(c,expl);
        { OID gc_local;
          ITERATE(v);
          bag *v_support;
          v_support = GC_OBJECT(list,c->vars);
          for (START(v_support); NEXT(v);)
          { GC_LOOP;
            palm_self_explain_PalmIntVar1(OBJECT(PalmIntVar,v),4,expl);
            GC_UNLOOP;} 
          } 
        palm_raisePalmFakeContradiction_PalmEngine(GC_OBJECT(PalmEngine,((PalmEngine *) choco_getProblem_AbstractConstraint(c)->propagationEngine)),expl);
        } 
      } 
    else { { int  g0139 = c->nbLeftVertices;
          int  g0140 = c->nbRightVertices;
          (ice.CHK->value= _oid_(c));
          ;} 
        } 
      } 
  GC_UNBIND;} 


/* The c++ function for: removeUselessEdges(c:PalmCompleteAllDiff) [] */
void  palm_removeUselessEdges_PalmCompleteAllDiff(PalmCompleteAllDiff *c)
{ GC_RESERVE(1);  // HOHO v3.0.55 optim !
  ;if (c->matchingSize < c->nbLeftVertices)
   { (*ice.augmentFlow)(_oid_(c));
    } 
  { int  n1 = c->nbLeftVertices;
    int  n2 = c->nbRightVertices;
    ice_firstPassDFS_AbstractBipartiteMatching(c);
    ice_secondPassDFS_AbstractBipartiteMatching(c);
    { int  i = 1;
      int  g0143 = n1;
      { OID gc_local;
        while ((i <= g0143))
        { // HOHO, GC_LOOP not needed !
          ++i;
          } 
        } 
      } 
    { int  j = 1;
      int  g0144 = n2;
      { OID gc_local;
        while ((j <= g0144))
        { // HOHO, GC_LOOP not needed !
          ++j;
          } 
        } 
      } 
    { int  nkept = 0;
      int  ndiscard = 0;
      { int  i = 1;
        int  g0145 = c->nbLeftVertices;
        { OID gc_local;
          while ((i <= g0145))
          { GC_LOOP;
            { IntVar * g0148 = OBJECT(IntVar,(*(c->vars))[i]);
              AbstractIntDomain * g0149 = GC_OBJECT(AbstractIntDomain,g0148->bucket);
              if (g0149 == (NULL))
               { int  g0147 = g0148->inf->latestValue;
                { OID gc_local;
                  while ((g0147 <= g0148->sup->latestValue))
                  { // HOHO, GC_LOOP not needed !
                    { int  j = ((g0147-c->minValue)+1);
                      if (j != ((OID *) c->refMatch)[i])
                       { if (((OID *) c->component)[i] != ((OID *) c->component)[(j+n1)])
                         { ++ndiscard;
                          choco_deleteEdgeAndPublish_PalmCompleteAllDiff(c,i,j);
                          } 
                        else ++nkept;
                          } 
                      } 
                    g0147= ((g0148->inf->latestValue <= (g0147+1)) ?
                      (g0147+1) :
                      g0148->inf->latestValue );
                    } 
                  } 
                } 
              else if (INHERIT(g0149->isa,choco._LinkedListIntDomain))
               { int  g0147 = g0148->inf->latestValue;
                { OID gc_local;
                  while ((g0147 <= g0148->sup->latestValue))
                  { // HOHO, GC_LOOP not needed !
                    { int  j = ((g0147-c->minValue)+1);
                      if (j != ((OID *) c->refMatch)[i])
                       { if (((OID *) c->component)[i] != ((OID *) c->component)[(j+n1)])
                         { ++ndiscard;
                          choco_deleteEdgeAndPublish_PalmCompleteAllDiff(c,i,j);
                          } 
                        else ++nkept;
                          } 
                      } 
                    g0147= choco.getNextValue->fcall(((int) g0149),((int) g0147));
                    } 
                  } 
                } 
              else { OID gc_local;
                  ITERATE(g0147);
                  bag *g0147_support;
                  g0147_support = GC_OBJECT(list,OBJECT(bag,_oid_((ClaireObject *) choco.domainSequence->fcall(((int) g0149)))));
                  for (START(g0147_support); NEXT(g0147);)
                  { GC_LOOP;
                    { int  j = ((g0147-c->minValue)+1);
                      if (j != ((OID *) c->refMatch)[i])
                       { if (((OID *) c->component)[i] != ((OID *) c->component)[(j+n1)])
                         { ++ndiscard;
                          choco_deleteEdgeAndPublish_PalmCompleteAllDiff(c,i,j);
                          } 
                        else ++nkept;
                          } 
                      } 
                    GC_UNLOOP;} 
                  } 
                } 
            ++i;
            GC_UNLOOP;} 
          } 
        } 
      ;} 
    } 
  GC_UNBIND;} 


/* The c++ function for: removeUselessEdges(c:PalmPermutation) [] */
void  palm_removeUselessEdges_PalmPermutation(PalmPermutation *c)
{ GC_RESERVE(1);  // HOHO v3.0.55 optim !
  ;if (c->matchingSize < c->nbLeftVertices)
   { (*ice.augmentFlow)(_oid_(c));
    } 
  { int  n1 = c->nbLeftVertices;
    int  n2 = c->nbRightVertices;
    ice_firstPassDFS_AbstractBipartiteMatching(c);
    ice_secondPassDFS_AbstractBipartiteMatching(c);
    { int  i = 1;
      int  g0150 = n1;
      { OID gc_local;
        while ((i <= g0150))
        { // HOHO, GC_LOOP not needed !
          ++i;
          } 
        } 
      } 
    { int  j = 1;
      int  g0151 = n2;
      { OID gc_local;
        while ((j <= g0151))
        { // HOHO, GC_LOOP not needed !
          ++j;
          } 
        } 
      } 
    { int  nkept = 0;
      int  ndiscard = 0;
      { int  i = 1;
        int  g0152 = c->nbLeftVertices;
        { OID gc_local;
          while ((i <= g0152))
          { GC_LOOP;
            { IntVar * g0155 = OBJECT(IntVar,(*(c->vars))[i]);
              AbstractIntDomain * g0156 = GC_OBJECT(AbstractIntDomain,g0155->bucket);
              if (g0156 == (NULL))
               { int  g0154 = g0155->inf->latestValue;
                { OID gc_local;
                  while ((g0154 <= g0155->sup->latestValue))
                  { // HOHO, GC_LOOP not needed !
                    { int  j = ((g0154-c->minValue)+1);
                      if (j != ((OID *) c->refMatch)[i])
                       { if (((OID *) c->component)[i] != ((OID *) c->component)[(j+n1)])
                         { ++ndiscard;
                          choco_deleteEdgeAndPublish_PalmPermutation(c,i,j);
                          } 
                        else ++nkept;
                          } 
                      } 
                    g0154= ((g0155->inf->latestValue <= (g0154+1)) ?
                      (g0154+1) :
                      g0155->inf->latestValue );
                    } 
                  } 
                } 
              else if (INHERIT(g0156->isa,choco._LinkedListIntDomain))
               { int  g0154 = g0155->inf->latestValue;
                { OID gc_local;
                  while ((g0154 <= g0155->sup->latestValue))
                  { // HOHO, GC_LOOP not needed !
                    { int  j = ((g0154-c->minValue)+1);
                      if (j != ((OID *) c->refMatch)[i])
                       { if (((OID *) c->component)[i] != ((OID *) c->component)[(j+n1)])
                         { ++ndiscard;
                          choco_deleteEdgeAndPublish_PalmPermutation(c,i,j);
                          } 
                        else ++nkept;
                          } 
                      } 
                    g0154= choco.getNextValue->fcall(((int) g0156),((int) g0154));
                    } 
                  } 
                } 
              else { OID gc_local;
                  ITERATE(g0154);
                  bag *g0154_support;
                  g0154_support = GC_OBJECT(list,OBJECT(bag,_oid_((ClaireObject *) choco.domainSequence->fcall(((int) g0156)))));
                  for (START(g0154_support); NEXT(g0154);)
                  { GC_LOOP;
                    { int  j = ((g0154-c->minValue)+1);
                      if (j != ((OID *) c->refMatch)[i])
                       { if (((OID *) c->component)[i] != ((OID *) c->component)[(j+n1)])
                         { ++ndiscard;
                          choco_deleteEdgeAndPublish_PalmPermutation(c,i,j);
                          } 
                        else ++nkept;
                          } 
                      } 
                    GC_UNLOOP;} 
                  } 
                } 
            ++i;
            GC_UNLOOP;} 
          } 
        } 
      ;} 
    } 
  GC_UNBIND;} 


/* The c++ function for: removeUselessEdges(c:PalmGlobalCardinality) [] */
void  palm_removeUselessEdges_PalmGlobalCardinality(PalmGlobalCardinality *c)
{ GC_RESERVE(1);  // HOHO v3.0.55 optim !
  ;if (c->matchingSize < c->nbLeftVertices)
   { (*ice.augmentFlow)(_oid_(c));
    } 
  { int  n1 = c->nbLeftVertices;
    int  n2 = c->nbRightVertices;
    ice_firstPassDFS_AbstractBipartiteFlow(c);
    ice_secondPassDFS_AbstractBipartiteFlow(c);
    { int  i = 1;
      int  g0157 = n1;
      { OID gc_local;
        while ((i <= g0157))
        { // HOHO, GC_LOOP not needed !
          ++i;
          } 
        } 
      } 
    { int  j = 1;
      int  g0158 = n2;
      { OID gc_local;
        while ((j <= g0158))
        { // HOHO, GC_LOOP not needed !
          ++j;
          } 
        } 
      } 
    { int  nkept = 0;
      int  ndiscard = 0;
      { int  i = 1;
        int  g0159 = c->nbLeftVertices;
        { OID gc_local;
          while ((i <= g0159))
          { GC_LOOP;
            { IntVar * g0162 = OBJECT(IntVar,(*(c->vars))[i]);
              AbstractIntDomain * g0163 = GC_OBJECT(AbstractIntDomain,g0162->bucket);
              if (g0163 == (NULL))
               { int  g0161 = g0162->inf->latestValue;
                { OID gc_local;
                  while ((g0161 <= g0162->sup->latestValue))
                  { // HOHO, GC_LOOP not needed !
                    { int  j = ((g0161-c->minValue)+1);
                      if (j != ((OID *) c->refMatch)[i])
                       { if (((OID *) c->component)[i] != ((OID *) c->component)[(j+n1)])
                         { ++ndiscard;
                          choco_deleteEdgeAndPublish_PalmGlobalCardinality(c,i,j);
                          } 
                        else ++nkept;
                          } 
                      } 
                    g0161= ((g0162->inf->latestValue <= (g0161+1)) ?
                      (g0161+1) :
                      g0162->inf->latestValue );
                    } 
                  } 
                } 
              else if (INHERIT(g0163->isa,choco._LinkedListIntDomain))
               { int  g0161 = g0162->inf->latestValue;
                { OID gc_local;
                  while ((g0161 <= g0162->sup->latestValue))
                  { // HOHO, GC_LOOP not needed !
                    { int  j = ((g0161-c->minValue)+1);
                      if (j != ((OID *) c->refMatch)[i])
                       { if (((OID *) c->component)[i] != ((OID *) c->component)[(j+n1)])
                         { ++ndiscard;
                          choco_deleteEdgeAndPublish_PalmGlobalCardinality(c,i,j);
                          } 
                        else ++nkept;
                          } 
                      } 
                    g0161= choco.getNextValue->fcall(((int) g0163),((int) g0161));
                    } 
                  } 
                } 
              else { OID gc_local;
                  ITERATE(g0161);
                  bag *g0161_support;
                  g0161_support = GC_OBJECT(list,OBJECT(bag,_oid_((ClaireObject *) choco.domainSequence->fcall(((int) g0163)))));
                  for (START(g0161_support); NEXT(g0161);)
                  { GC_LOOP;
                    { int  j = ((g0161-c->minValue)+1);
                      if (j != ((OID *) c->refMatch)[i])
                       { if (((OID *) c->component)[i] != ((OID *) c->component)[(j+n1)])
                         { ++ndiscard;
                          choco_deleteEdgeAndPublish_PalmGlobalCardinality(c,i,j);
                          } 
                        else ++nkept;
                          } 
                      } 
                    GC_UNLOOP;} 
                  } 
                } 
            ++i;
            GC_UNLOOP;} 
          } 
        } 
      ;} 
    } 
  GC_UNBIND;} 


// *************************************************************
// * Part 5 : OCCUR constraint                                 *
// *************************************************************
// * 1 : model 
// * 2 : propagation Tools                                     
/* The c++ function for: checkNbPossible(c:PalmOccurrence) [] */
void  palm_checkNbPossible_PalmOccurrence(PalmOccurrence *c)
{ GC_BIND;
  ;{ list * l = GC_OBJECT(list,c->vars);
    int  n = c->nbVars;
    OID  nbVar = (*(l))[n];
    int  tgt = c->cste;
    if (c->constrainOnInfNumber == CTRUE)
     { Explanation * expl;
      { { Explanation * _CL_obj = ((Explanation *) GC_OBJECT(Explanation,new_object_class(palm._Explanation)));
          expl = _CL_obj;
          } 
        GC_OBJECT(Explanation,expl);} 
      palm_self_explain_AbstractConstraint(c,expl);
      { int  i = 1;
        int  g0164 = (n-1);
        { OID gc_local;
          while ((i <= g0164))
          { // HOHO, GC_LOOP not needed !
            if (not_any(((OID *) c->isPossible)[i]) == CTRUE)
             palm_self_explain_PalmIntVar2(OBJECT(PalmIntVar,(*(l))[i]),3,tgt,expl);
            ++i;
            } 
          } 
        } 
      (*choco.updateSup)(nbVar,
        c->nbPossible,
        (*(c->indices))[n],
        GC_OID(_oid_(palm_clone_Explanation(expl))));
      if (choco.getInf->fcall(((int) OBJECT(ClaireObject,nbVar))) == c->nbPossible)
       { palm_self_explain_PalmIntVar1(OBJECT(PalmIntVar,nbVar),1,expl);
        { int  i = 1;
          int  g0165 = (n-1);
          { OID gc_local;
            while ((i <= g0165))
            { GC_LOOP;
              if ((OBJECT(ClaireBoolean,((OID *) c->isPossible)[i])) == CTRUE)
               choco_instantiate_PalmIntVar(OBJECT(PalmIntVar,(*(l))[i]),tgt,(*(c->indices))[i],GC_OBJECT(Explanation,palm_clone_Explanation(expl)));
              ++i;
              GC_UNLOOP;} 
            } 
          } 
        } 
      } 
    (c->checkPossible = CFALSE);
    } 
  GC_UNBIND;} 


/* The c++ function for: checkNbSure(c:PalmOccurrence) [] */
void  palm_checkNbSure_PalmOccurrence(PalmOccurrence *c)
{ GC_BIND;
  { list * l = GC_OBJECT(list,c->vars);
    int  n = c->nbVars;
    OID  nbVar = (*(l))[n];
    int  tgt = c->cste;
    if (c->constrainOnSupNumber == CTRUE)
     { Explanation * expl;
      { { Explanation * _CL_obj = ((Explanation *) GC_OBJECT(Explanation,new_object_class(palm._Explanation)));
          expl = _CL_obj;
          } 
        GC_OBJECT(Explanation,expl);} 
      palm_self_explain_AbstractConstraint(c,expl);
      { int  i = 1;
        int  g0166 = (n-1);
        { OID gc_local;
          while ((i <= g0166))
          { // HOHO, GC_LOOP not needed !
            if ((OBJECT(ClaireBoolean,((OID *) c->isSure)[i])) == CTRUE)
             palm_self_explain_PalmIntVar1(OBJECT(PalmIntVar,(*(l))[i]),4,expl);
            ++i;
            } 
          } 
        } 
      (*choco.updateInf)(nbVar,
        c->nbSure,
        (*(c->indices))[n],
        GC_OID(_oid_(palm_clone_Explanation(expl))));
      if (choco.getSup->fcall(((int) OBJECT(ClaireObject,nbVar))) == c->nbSure)
       { palm_self_explain_PalmIntVar1(OBJECT(PalmIntVar,nbVar),2,expl);
        { int  i = 1;
          int  g0167 = (n-1);
          { OID gc_local;
            while ((i <= g0167))
            { GC_LOOP;
              if (((OBJECT(ClaireBoolean,((OID *) c->isPossible)[i])) == CTRUE) && 
                  (not_any(_oid_((ClaireObject *) choco.isInstantiated->fcall(((int) OBJECT(ClaireObject,(*(l))[i]))))) == CTRUE))
               (*choco.removeVal)((*(l))[i],
                tgt,
                (*(c->indices))[i],
                GC_OID(_oid_(palm_clone_Explanation(expl))));
              ++i;
              GC_UNLOOP;} 
            } 
          } 
        } 
      } 
    (c->checkSure = CFALSE);
    } 
  GC_UNBIND;} 


// updating DS on reducing the bounds of variable v
/* The c++ function for: updateDataStructuresOnConstraint(c:PalmOccurrence,idx:integer,way:{1, 2, 3, 4},newValue:integer,oldValue:integer) [] */
void  palm_updateDataStructuresOnConstraint_PalmOccurrence_palm(PalmOccurrence *c,int idx,int way,int newValue,int oldValue)
{ GC_BIND;
  if (way == 3)
   { if (idx < c->nbVars)
     { if ((newValue == c->cste) && 
          ((OBJECT(ClaireBoolean,((OID *) c->isPossible)[idx])) == CTRUE))
       { (((OID *) c->isPossible)[idx] = Kernel.cfalse);
        STOREI(c->nbPossible,(c->nbPossible-1));
        (c->checkPossible = CTRUE);
        if ((OBJECT(ClaireBoolean,((OID *) c->isSure)[idx])) == CTRUE)
         { (((OID *) c->isSure)[idx] = Kernel.cfalse);
          STOREI(c->nbSure,(c->nbSure-1));
          (c->checkSure = CTRUE);
          } 
        } 
      if ((OBJECT(ClaireBoolean,_oid_((ClaireObject *) choco.isInstantiated->fcall(((int) OBJECT(ClaireObject,(*(c->vars))[idx])))))) == CTRUE)
       { OID  val = GC_OID(get_property(Kernel.value,OBJECT(ClaireObject,(*(c->vars))[idx])));
        if ((val == c->cste) && 
            (not_any(((OID *) c->isSure)[idx]) == CTRUE))
         { (((OID *) c->isSure)[idx] = Kernel.ctrue);
          STOREI(c->nbSure,(c->nbSure+1));
          (c->checkSure = CTRUE);
          } 
        } 
      } 
    else { (c->checkSure = CTRUE);
        (c->checkPossible = CTRUE);
        } 
      if (newValue < choco.getInf->fcall(((int) OBJECT(ClaireObject,(*(c->vars))[idx]))))
     ((*(c->checkInf))[idx]=Kernel.ctrue);
    if (newValue > choco.getSup->fcall(((int) OBJECT(ClaireObject,(*(c->vars))[idx]))))
     ((*(c->checkSup))[idx]=Kernel.ctrue);
    } 
  else if (way == 1)
   { if (idx < c->nbVars)
     { if (((OBJECT(ClaireBoolean,((OID *) c->isPossible)[idx])) == CTRUE) && 
          (newValue > c->cste))
       { (((OID *) c->isPossible)[idx] = Kernel.cfalse);
        STOREI(c->nbPossible,(c->nbPossible-1));
        (c->checkPossible = CTRUE);
        if ((OBJECT(ClaireBoolean,((OID *) c->isSure)[idx])) == CTRUE)
         { (((OID *) c->isSure)[idx] = Kernel.cfalse);
          STOREI(c->nbSure,(c->nbSure-1));
          (c->checkSure = CTRUE);
          } 
        } 
      if ((OBJECT(ClaireBoolean,_oid_((ClaireObject *) choco.isInstantiated->fcall(((int) OBJECT(ClaireObject,(*(c->vars))[idx])))))) == CTRUE)
       { OID  val = GC_OID(get_property(Kernel.value,OBJECT(ClaireObject,(*(c->vars))[idx])));
        if ((val == c->cste) && 
            (not_any(((OID *) c->isSure)[idx]) == CTRUE))
         { (((OID *) c->isSure)[idx] = Kernel.ctrue);
          STOREI(c->nbSure,(c->nbSure+1));
          (c->checkSure = CTRUE);
          } 
        } 
      } 
    else { (c->checkSure = CTRUE);
        (c->checkPossible = CTRUE);
        } 
      } 
  else if (way == 2)
   { if (idx < c->nbVars)
     { if (((OBJECT(ClaireBoolean,((OID *) c->isPossible)[idx])) == CTRUE) && 
          (newValue < c->cste))
       { (((OID *) c->isPossible)[idx] = Kernel.cfalse);
        STOREI(c->nbPossible,(c->nbPossible-1));
        (c->checkPossible = CTRUE);
        if ((OBJECT(ClaireBoolean,((OID *) c->isSure)[idx])) == CTRUE)
         { (((OID *) c->isSure)[idx] = Kernel.cfalse);
          STOREI(c->nbSure,(c->nbSure-1));
          (c->checkSure = CTRUE);
          } 
        } 
      if ((OBJECT(ClaireBoolean,_oid_((ClaireObject *) choco.isInstantiated->fcall(((int) OBJECT(ClaireObject,(*(c->vars))[idx])))))) == CTRUE)
       { OID  val = GC_OID(get_property(Kernel.value,OBJECT(ClaireObject,(*(c->vars))[idx])));
        if ((val == c->cste) && 
            (not_any(((OID *) c->isSure)[idx]) == CTRUE))
         { (((OID *) c->isSure)[idx] = Kernel.ctrue);
          STOREI(c->nbSure,(c->nbSure+1));
          (c->checkSure = CTRUE);
          } 
        } 
      } 
    else { (c->checkSure = CTRUE);
        (c->checkPossible = CTRUE);
        } 
      } 
  GC_UNBIND;} 


// updating DS on enlargin the bounds of variable v
/* The c++ function for: updateDataStructuresOnRestoreConstraint(c:PalmOccurrence,idx:integer,way:{1, 2, 3, 4},newValue:integer,oldValue:integer) [] */
OID  palm_updateDataStructuresOnRestoreConstraint_PalmOccurrence_palm(PalmOccurrence *c,int idx,int way,int newValue,int oldValue)
{ GC_BIND;
  { OID Result = 0;
    if (way == 3)
     { if (idx < c->nbVars)
       { if (newValue == c->cste)
         { if (not_any(((OID *) c->isPossible)[idx]) == CTRUE)
           { (((OID *) c->isPossible)[idx] = Kernel.ctrue);
            STOREI(c->nbPossible,(c->nbPossible+1));
            (c->checkPossible = CTRUE);
            } 
          if ((OBJECT(ClaireBoolean,_oid_((ClaireObject *) choco.isInstantiated->fcall(((int) OBJECT(ClaireObject,(*(c->vars))[idx])))))) == CTRUE)
           { OID  val = GC_OID(get_property(Kernel.value,OBJECT(ClaireObject,(*(c->vars))[idx])));
            if (not_any(((OID *) c->isSure)[idx]) == CTRUE)
             { (((OID *) c->isSure)[idx] = Kernel.ctrue);
              STOREI(c->nbSure,(c->nbSure+1));
              (c->checkSure = CTRUE);
              } 
            } 
          } 
        else if ((OBJECT(ClaireBoolean,((OID *) c->isSure)[idx])) == CTRUE)
         { (((OID *) c->isSure)[idx] = Kernel.cfalse);
          STOREI(c->nbSure,(c->nbSure-1));
          (c->checkSure = CTRUE);
          } 
        } 
      else { (c->checkPossible = CTRUE);
          (c->checkSure = CTRUE);
          } 
        ((*(c->checkInf))[idx]=Kernel.ctrue);
      Result = ((*(c->checkSup))[idx]=Kernel.ctrue);
      } 
    else if (way == 1)
     { if (idx < c->nbVars)
       { if ((newValue <= c->cste) && 
            ((oldValue > c->cste) && 
              (newValue <= choco.getSup->fcall(((int) OBJECT(ClaireObject,(*(c->vars))[idx]))))))
         { (((OID *) c->isPossible)[idx] = Kernel.ctrue);
          STOREI(c->nbPossible,(c->nbPossible+1));
          (c->checkPossible = CTRUE);
          if ((OBJECT(ClaireBoolean,_oid_((ClaireObject *) choco.isInstantiated->fcall(((int) OBJECT(ClaireObject,(*(c->vars))[idx])))))) == CTRUE)
           { OID  val = GC_OID(get_property(Kernel.value,OBJECT(ClaireObject,(*(c->vars))[idx])));
            if ((val == c->cste) && 
                (not_any(((OID *) c->isSure)[idx]) == CTRUE))
             { (((OID *) c->isSure)[idx] = Kernel.ctrue);
              STOREI(c->nbSure,(c->nbSure+1));
              (c->checkSure = CTRUE);
              } 
            else if ((val != c->cste) && 
                ((OBJECT(ClaireBoolean,((OID *) c->isSure)[idx])) == CTRUE))
             { (((OID *) c->isSure)[idx] = Kernel.cfalse);
              STOREI(c->nbSure,(c->nbSure-1));
              (c->checkSure = CTRUE);
              } 
            } 
          } 
        if (((OBJECT(ClaireBoolean,((OID *) c->isSure)[idx])) == CTRUE) && 
            (choco.getInf->fcall(((int) OBJECT(ClaireObject,(*(c->vars))[idx]))) != c->cste))
         { (((OID *) c->isSure)[idx] = Kernel.cfalse);
          STOREI(c->nbSure,(c->nbSure-1));
          Result = _void_((c->checkSure = CTRUE));
          } 
        else Result = Kernel.cfalse;
          } 
      else { ((*(c->checkInf))[idx]=Kernel.ctrue);
          Result = ((*(c->checkSup))[idx]=Kernel.ctrue);
          } 
        } 
    else if (way == 2)
     { if (idx < c->nbVars)
       { if ((c->cste <= newValue) && 
            ((oldValue < c->cste) && 
              (choco.getInf->fcall(((int) OBJECT(ClaireObject,(*(c->vars))[idx]))) <= newValue)))
         { (((OID *) c->isPossible)[idx] = Kernel.ctrue);
          STOREI(c->nbPossible,(c->nbPossible+1));
          (c->checkPossible = CTRUE);
          if ((OBJECT(ClaireBoolean,_oid_((ClaireObject *) choco.isInstantiated->fcall(((int) OBJECT(ClaireObject,(*(c->vars))[idx])))))) == CTRUE)
           { OID  val = GC_OID(get_property(Kernel.value,OBJECT(ClaireObject,(*(c->vars))[idx])));
            if ((val == c->cste) && 
                (not_any(((OID *) c->isSure)[idx]) == CTRUE))
             { (((OID *) c->isSure)[idx] = Kernel.ctrue);
              STOREI(c->nbSure,(c->nbSure+1));
              (c->checkSure = CTRUE);
              } 
            else if ((val != c->cste) && 
                ((OBJECT(ClaireBoolean,((OID *) c->isSure)[idx])) == CTRUE))
             { (((OID *) c->isSure)[idx] = Kernel.cfalse);
              STOREI(c->nbSure,(c->nbSure-1));
              (c->checkSure = CTRUE);
              } 
            } 
          } 
        if (((OBJECT(ClaireBoolean,((OID *) c->isSure)[idx])) == CTRUE) && 
            (choco.getSup->fcall(((int) OBJECT(ClaireObject,(*(c->vars))[idx]))) != c->cste))
         { (((OID *) c->isSure)[idx] = Kernel.cfalse);
          STOREI(c->nbSure,(c->nbSure-1));
          Result = _void_((c->checkSure = CTRUE));
          } 
        else Result = Kernel.cfalse;
          } 
      else { ((*(c->checkInf))[idx]=Kernel.ctrue);
          Result = ((*(c->checkSup))[idx]=Kernel.ctrue);
          } 
        } 
    else Result = Kernel.cfalse;
      GC_UNBIND; return (Result);} 
  } 


// <thb> v0.31: There is a smart propagation path, when the variables are BoundIntVar (no bucket):
// When the number of occurrences has already reached its max, then, the additional
// possible occurrences of the value should be forbidden. Therefore whenever the bound
// of a variable reaches the target value, this value can be shaved off and the bound improved by 1.
/* The c++ function for: choco/awakeOnInf(c:PalmOccurrence,idx:integer) [] */
void  choco_awakeOnInf_PalmOccurrence(PalmOccurrence *c,int idx)
{ GC_BIND;
  if (idx < c->nbVars)
   { if (c->checkPossible == CTRUE)
     palm_checkNbPossible_PalmOccurrence(c);
    if (c->checkSure == CTRUE)
     palm_checkNbSure_PalmOccurrence(c);
    if (((OBJECT(ClaireBoolean,((OID *) c->isPossible)[idx])) == CTRUE) && 
        (choco.getInf->fcall(((int) OBJECT(ClaireObject,(*(c->vars))[idx]))) == c->cste))
     { if ((not_any(((OID *) c->isSure)[idx]) == CTRUE) && 
          ((c->constrainOnSupNumber == CTRUE) && 
            (c->nbSure == choco.getSup->fcall(((int) OBJECT(ClaireObject,(*(c->vars))[c->nbVars]))))))
       { Explanation * expl;
        { { Explanation * _CL_obj = ((Explanation *) GC_OBJECT(Explanation,new_object_class(palm._Explanation)));
            expl = _CL_obj;
            } 
          GC_OBJECT(Explanation,expl);} 
        palm_self_explain_AbstractConstraint(c,expl);
        palm_self_explain_PalmIntVar1(OBJECT(PalmIntVar,(*(c->vars))[idx]),1,expl);
        palm_self_explain_PalmIntVar1(OBJECT(PalmIntVar,(*(c->vars))[c->nbVars]),2,expl);
        { int  i = 1;
          int  g0168 = (c->nbVars-1);
          { OID gc_local;
            while ((i <= g0168))
            { // HOHO, GC_LOOP not needed !
              if ((OBJECT(ClaireBoolean,((OID *) c->isSure)[i])) == CTRUE)
               palm_self_explain_PalmIntVar1(OBJECT(PalmIntVar,(*(c->vars))[i]),4,expl);
              ++i;
              } 
            } 
          } 
        (*choco.updateInf)((*(c->vars))[idx],
          (c->cste+1),
          (*(c->indices))[idx],
          _oid_(expl));
        } 
      } 
    } 
  else palm_checkNbPossible_PalmOccurrence(c);
    ((*(c->checkInf))[idx]=Kernel.cfalse);
  GC_UNBIND;} 


/* The c++ function for: choco/awakeOnSup(c:PalmOccurrence,idx:integer) [] */
void  choco_awakeOnSup_PalmOccurrence(PalmOccurrence *c,int idx)
{ GC_BIND;
  if (idx < c->nbVars)
   { if (c->checkPossible == CTRUE)
     palm_checkNbPossible_PalmOccurrence(c);
    if (c->checkSure == CTRUE)
     palm_checkNbSure_PalmOccurrence(c);
    if (((OBJECT(ClaireBoolean,((OID *) c->isPossible)[idx])) == CTRUE) && 
        (c->cste <= choco.getSup->fcall(((int) OBJECT(ClaireObject,(*(c->vars))[idx])))))
     { if ((not_any(((OID *) c->isSure)[idx]) == CTRUE) && 
          ((c->constrainOnSupNumber == CTRUE) && 
            (c->nbSure == choco.getSup->fcall(((int) OBJECT(ClaireObject,(*(c->vars))[c->nbVars]))))))
       { Explanation * expl;
        { { Explanation * _CL_obj = ((Explanation *) GC_OBJECT(Explanation,new_object_class(palm._Explanation)));
            expl = _CL_obj;
            } 
          GC_OBJECT(Explanation,expl);} 
        palm_self_explain_AbstractConstraint(c,expl);
        palm_self_explain_PalmIntVar1(OBJECT(PalmIntVar,(*(c->vars))[idx]),2,expl);
        palm_self_explain_PalmIntVar1(OBJECT(PalmIntVar,(*(c->vars))[c->nbVars]),2,expl);
        { int  i = 1;
          int  g0169 = (c->nbVars-1);
          { OID gc_local;
            while ((i <= g0169))
            { // HOHO, GC_LOOP not needed !
              if ((OBJECT(ClaireBoolean,((OID *) c->isSure)[i])) == CTRUE)
               palm_self_explain_PalmIntVar1(OBJECT(PalmIntVar,(*(c->vars))[i]),4,expl);
              ++i;
              } 
            } 
          } 
        (*choco.updateSup)((*(c->vars))[idx],
          (c->cste-1),
          (*(c->indices))[idx],
          _oid_(expl));
        } 
      } 
    } 
  else palm_checkNbSure_PalmOccurrence(c);
    ((*(c->checkSup))[idx]=Kernel.cfalse);
  GC_UNBIND;} 


/* The c++ function for: choco/awakeOnRem(c:PalmOccurrence,idx:integer,x:integer) [] */
void  choco_awakeOnRem_PalmOccurrence(PalmOccurrence *c,int idx,int x)
{ if (c->checkPossible == CTRUE)
   palm_checkNbPossible_PalmOccurrence(c);
  if (c->checkSure == CTRUE)
   palm_checkNbSure_PalmOccurrence(c);
  if ((OBJECT(ClaireBoolean,(*(c->checkInf))[idx])) == CTRUE)
   choco_awakeOnInf_PalmOccurrence(c,idx);
  if ((OBJECT(ClaireBoolean,(*(c->checkSup))[idx])) == CTRUE)
   choco_awakeOnSup_PalmOccurrence(c,idx);
  } 


/* The c++ function for: awakeOnRestoreInf(c:PalmOccurrence,i:integer) [] */
void  palm_awakeOnRestoreInf_PalmOccurrence(PalmOccurrence *c,int i)
{ choco_update_Occurrence(c);
  } 


/* The c++ function for: awakeOnRestoreSup(c:PalmOccurrence,i:integer) [] */
void  palm_awakeOnRestoreSup_PalmOccurrence(PalmOccurrence *c,int i)
{ choco_update_Occurrence(c);
  } 


/* The c++ function for: awakeOnRestoreVal(c:PalmOccurrence,i:integer,v:integer) [] */
void  palm_awakeOnRestoreVal_PalmOccurrence(PalmOccurrence *c,int i,int v)
{ choco_update_Occurrence(c);
  } 


/* The c++ function for: choco/awake(c:PalmOccurrence) [] */
void  choco_awake_PalmOccurrence_palm(PalmOccurrence *c)
{ GC_BIND;
  { int  n = c->nbVars;
    IntVar * nbVar = OBJECT(IntVar,(*(c->vars))[n]);
    Explanation * e;
    { { Explanation * _CL_obj = ((Explanation *) GC_OBJECT(Explanation,new_object_class(palm._Explanation)));
        e = _CL_obj;
        } 
      GC_OBJECT(Explanation,e);} 
    palm_self_explain_AbstractConstraint(c,e);
    if (c->constrainOnInfNumber == CTRUE)
     (*choco.updateSup)(_oid_(nbVar),
      n,
      (*(c->indices))[n],
      GC_OID(_oid_(palm_clone_Explanation(e))));
    if (c->constrainOnSupNumber == CTRUE)
     (*choco.updateInf)(_oid_(nbVar),
      0,
      (*(c->indices))[n],
      GC_OID(_oid_(palm_clone_Explanation(e))));
    } 
  choco_propagate_Occurrence(c);
  ;GC_UNBIND;} 


// <thb> v0.93
/* The c++ function for: choco/testIfSatisfied(c:PalmOccurrence) [] */
ClaireBoolean * choco_testIfSatisfied_PalmOccurrence(PalmOccurrence *c)
{ return (CTRUE);} 


// <thb> v0.93
/* The c++ function for: choco/askIfEntailed(c:PalmOccurrence) [] */
OID  choco_askIfEntailed_PalmOccurrence(PalmOccurrence *c)
{ { OID Result = 0;
    { OID  occ = (*(c->vars))[c->nbVars];
      int  nbS;
      { int  g0170 = 0;
        { int  g0171 = 1;
          int  g0172 = (c->nbVars-1);
          { OID gc_local;
            while ((g0171 <= g0172))
            { // HOHO, GC_LOOP not needed !
              if ((OBJECT(ClaireBoolean,(*choco.isInstantiatedTo)((*(c->vars))[g0171],
                c->cste))) == CTRUE)
               ++g0170;
              ++g0171;
              } 
            } 
          } 
        nbS = g0170;
        } 
      int  nbP;
      { int  g0173 = 0;
        { int  g0174 = 1;
          int  g0175 = (c->nbVars-1);
          { OID gc_local;
            while ((g0174 <= g0175))
            { // HOHO, GC_LOOP not needed !
              if ((OBJECT(ClaireBoolean,(*choco.canBeInstantiatedTo)((*(c->vars))[g0174],
                c->cste))) == CTRUE)
               ++g0173;
              ++g0174;
              } 
            } 
          } 
        nbP = g0173;
        } 
      if ((c->constrainOnSupNumber == CTRUE) && 
          (c->constrainOnInfNumber == CTRUE))
       { if (((OBJECT(ClaireBoolean,_oid_((ClaireObject *) choco.isInstantiated->fcall(((int) OBJECT(ClaireObject,occ)))))) == CTRUE) && 
            ((nbS == nbP) && 
              (OBJECT(IntVar,occ)->value == nbS)))
         Result = Kernel.ctrue;
        else if ((nbP < choco.getInf->fcall(((int) OBJECT(ClaireObject,occ)))) || 
            (nbS > choco.getSup->fcall(((int) OBJECT(ClaireObject,occ)))))
         Result = Kernel.cfalse;
        else Result = CNULL;
          } 
      else if (c->constrainOnInfNumber == CTRUE)
       { if (choco.getSup->fcall(((int) OBJECT(ClaireObject,occ))) <= nbS)
         Result = Kernel.ctrue;
        else if (nbP < choco.getInf->fcall(((int) OBJECT(ClaireObject,occ))))
         Result = Kernel.cfalse;
        else Result = CNULL;
          } 
      else if (c->constrainOnSupNumber == CTRUE)
       { if (nbP <= choco.getInf->fcall(((int) OBJECT(ClaireObject,occ))))
         Result = Kernel.ctrue;
        else if (nbS > choco.getSup->fcall(((int) OBJECT(ClaireObject,occ))))
         Result = Kernel.cfalse;
        else Result = CNULL;
          } 
      else close_exception(((general_error *) (*Core._general_error)(_string_("Stop and debug: constrainOnSupNumber or constrainOnInfNumber must be true in PalmOccurrence"),
          _oid_(Kernel.nil))));
        } 
    return (Result);} 
  } 


/* The c++ function for: checkPalm(ct:PalmOccurrence) [] */
ClaireBoolean * palm_checkPalm_PalmOccurrence(PalmOccurrence *ct)
{ return (CTRUE);} 


// claire3 port register no longer used
// ********************************************************************
// *  Part 6: accessing the ith element in a list of values           *
// ********************************************************************
// Element constraint
//   (accessing the ith element in a list of values, where i is a variable)
// the slot v1 represents the index and the slot v2 represents the value
// propagation with complete arc consistency from values to indices (v2 to v1)
// propagation with interval approximation from indices to values (v1 to v2)
// v0.34 uses the cste slot: l[i + cste] = x
// (ex: cste = 1 allows to use and index from 0 to length(l) - 1
// v0.9907: removed the method without the last argument
/* The c++ function for: makePalmEltConstraint(l:list[integer],i:PalmIntVar,x:PalmIntVar,o:integer) [] */
PalmElt * palm_makePalmEltConstraint_list(list *l,PalmIntVar *i,PalmIntVar *x,int o)
{ GC_BIND;
  { PalmElt *Result ;
    { PalmElt * c;
      { { PalmElt * _CL_obj = ((PalmElt *) GC_OBJECT(PalmElt,new_object_class(palm._PalmElt)));
          (_CL_obj->v1 = i);
          (_CL_obj->v2 = x);
          (_CL_obj->cste = o);
          (_CL_obj->lval = ((list *) copy_bag(l)));
          c = _CL_obj;
          } 
        GC_OBJECT(PalmElt,c);} 
      { AbstractConstraint * g0176; 
        OID  g0177;
        g0176 = c;
        { PalmInfoConstraint * _CL_obj = ((PalmInfoConstraint *) GC_OBJECT(PalmInfoConstraint,new_object_class(palm._PalmInfoConstraint)));
          g0177 = _oid_(_CL_obj);
          } 
        (g0176->hook = g0177);} 
      Result = c;
      } 
    GC_UNBIND; return (Result);} 
  } 


// v0.25 <fl> replaced all removeVal by remVal (in order to propagate induced consequences)
// v0.26 a few casts
/* The c++ function for: updateValueFromIndex(c:PalmElt) [] */
void  palm_updateValueFromIndex_PalmElt(PalmElt *c)
{ GC_RESERVE(1);  // HOHO v3.0.55 optim !
  { list * l = GC_OBJECT(list,c->lval);
    IntVar * indexVar = GC_OBJECT(IntVar,c->v1);
    IntVar * valueVar = GC_OBJECT(IntVar,c->v2);
    int  minval = 99999999;
    int  maxval = -99999999;
    Explanation * e;
    { { Explanation * _CL_obj = ((Explanation *) GC_OBJECT(Explanation,new_object_class(palm._Explanation)));
        e = _CL_obj;
        } 
      GC_OBJECT(Explanation,e);} 
    palm_self_explain_AbstractConstraint(c,e);
    palm_self_explain_PalmIntVar1(((PalmIntVar *) indexVar),4,e);
    { IntVar * g0178 = indexVar;
      AbstractIntDomain * g0179 = GC_OBJECT(AbstractIntDomain,g0178->bucket);
      if (g0179 == (NULL))
       { int  feasibleIndex = g0178->inf->latestValue;
        { OID gc_local;
          while ((feasibleIndex <= g0178->sup->latestValue))
          { // HOHO, GC_LOOP not needed !
            minval= claire_min_integer2(minval,(*(l))[(feasibleIndex+c->cste)]);
            maxval= claire_max_integer2(maxval,(*(l))[(feasibleIndex+c->cste)]);
            feasibleIndex= ((g0178->inf->latestValue <= (feasibleIndex+1)) ?
              (feasibleIndex+1) :
              g0178->inf->latestValue );
            } 
          } 
        } 
      else if (INHERIT(g0179->isa,choco._LinkedListIntDomain))
       { int  feasibleIndex = g0178->inf->latestValue;
        { OID gc_local;
          while ((feasibleIndex <= g0178->sup->latestValue))
          { // HOHO, GC_LOOP not needed !
            minval= claire_min_integer2(minval,(*(l))[(feasibleIndex+c->cste)]);
            maxval= claire_max_integer2(maxval,(*(l))[(feasibleIndex+c->cste)]);
            feasibleIndex= choco.getNextValue->fcall(((int) g0179),((int) feasibleIndex));
            } 
          } 
        } 
      else { OID gc_local;
          ITERATE(feasibleIndex);
          bag *feasibleIndex_support;
          feasibleIndex_support = GC_OBJECT(list,OBJECT(bag,_oid_((ClaireObject *) choco.domainSequence->fcall(((int) g0179)))));
          for (START(feasibleIndex_support); NEXT(feasibleIndex);)
          { GC_LOOP;
            { minval= claire_min_integer2(minval,(*(l))[(feasibleIndex+c->cste)]);
              maxval= claire_max_integer2(maxval,(*(l))[(feasibleIndex+c->cste)]);
              } 
            GC_UNLOOP;} 
          } 
        } 
    (*choco.updateInf)(_oid_(valueVar),
      minval,
      c->idx2,
      GC_OID(_oid_(palm_clone_Explanation(e))));
    (*choco.updateSup)(_oid_(valueVar),
      maxval,
      c->idx2,
      GC_OID(_oid_(palm_clone_Explanation(e))));
    if (get_property(choco.bucket,valueVar) != CNULL)
     { IntVar * g0180 = valueVar;
      AbstractIntDomain * g0181 = GC_OBJECT(AbstractIntDomain,g0180->bucket);
      if (g0181 == (NULL))
       { int  v = g0180->inf->latestValue;
        { OID gc_local;
          while ((v <= g0180->sup->latestValue))
          { GC_LOOP;
            { ClaireBoolean * g0188I;
              { OID  g0189UU;
                { ClaireBoolean * V_CL0190;{ OID  g0191UU;
                    { IntVar * g0182 = indexVar;
                      AbstractIntDomain * g0183 = GC_OBJECT(AbstractIntDomain,g0182->bucket);
                      if (g0183 == (NULL))
                       { int  i = g0182->inf->latestValue;
                        { OID gc_local;
                          g0191UU= _oid_(CFALSE);
                          while ((i <= g0182->sup->latestValue))
                          { // HOHO, GC_LOOP not needed !
                            if (v == (*(l))[(i+c->cste)])
                             { g0191UU = Kernel.ctrue;
                              break;} 
                            i= ((g0182->inf->latestValue <= (i+1)) ?
                              (i+1) :
                              g0182->inf->latestValue );
                            } 
                          } 
                        } 
                      else if (INHERIT(g0183->isa,choco._LinkedListIntDomain))
                       { int  i = g0182->inf->latestValue;
                        { OID gc_local;
                          g0191UU= _oid_(CFALSE);
                          while ((i <= g0182->sup->latestValue))
                          { // HOHO, GC_LOOP not needed !
                            if (v == (*(l))[(i+c->cste)])
                             { g0191UU = Kernel.ctrue;
                              break;} 
                            i= choco.getNextValue->fcall(((int) g0183),((int) i));
                            } 
                          } 
                        } 
                      else { OID gc_local;
                          ITERATE(i);
                          g0191UU= _oid_(CFALSE);
                          bag *i_support;
                          i_support = GC_OBJECT(list,OBJECT(bag,_oid_((ClaireObject *) choco.domainSequence->fcall(((int) g0183)))));
                          for (START(i_support); NEXT(i);)
                          { GC_LOOP;
                            if (v == (*(l))[(i+c->cste)])
                             { g0191UU = Kernel.ctrue;
                              break;} 
                            GC_UNLOOP;} 
                          } 
                        } 
                    V_CL0190 = boolean_I_any(g0191UU);
                    } 
                  
                  g0189UU=_oid_(V_CL0190);} 
                g0188I = not_any(g0189UU);
                } 
              
              if (g0188I == CTRUE) (*choco.removeVal)(_oid_(valueVar),
                  v,
                  c->idx2,
                  GC_OID(_oid_(palm_clone_Explanation(e))));
                } 
            v= ((g0180->inf->latestValue <= (v+1)) ?
              (v+1) :
              g0180->inf->latestValue );
            GC_UNLOOP;} 
          } 
        } 
      else if (INHERIT(g0181->isa,choco._LinkedListIntDomain))
       { int  v = g0180->inf->latestValue;
        { OID gc_local;
          while ((v <= g0180->sup->latestValue))
          { GC_LOOP;
            { ClaireBoolean * g0192I;
              { OID  g0193UU;
                { ClaireBoolean * V_CL0194;{ OID  g0195UU;
                    { IntVar * g0184 = indexVar;
                      AbstractIntDomain * g0185 = GC_OBJECT(AbstractIntDomain,g0184->bucket);
                      if (g0185 == (NULL))
                       { int  i = g0184->inf->latestValue;
                        { OID gc_local;
                          g0195UU= _oid_(CFALSE);
                          while ((i <= g0184->sup->latestValue))
                          { // HOHO, GC_LOOP not needed !
                            if (v == (*(l))[(i+c->cste)])
                             { g0195UU = Kernel.ctrue;
                              break;} 
                            i= ((g0184->inf->latestValue <= (i+1)) ?
                              (i+1) :
                              g0184->inf->latestValue );
                            } 
                          } 
                        } 
                      else if (INHERIT(g0185->isa,choco._LinkedListIntDomain))
                       { int  i = g0184->inf->latestValue;
                        { OID gc_local;
                          g0195UU= _oid_(CFALSE);
                          while ((i <= g0184->sup->latestValue))
                          { // HOHO, GC_LOOP not needed !
                            if (v == (*(l))[(i+c->cste)])
                             { g0195UU = Kernel.ctrue;
                              break;} 
                            i= choco.getNextValue->fcall(((int) g0185),((int) i));
                            } 
                          } 
                        } 
                      else { OID gc_local;
                          ITERATE(i);
                          g0195UU= _oid_(CFALSE);
                          bag *i_support;
                          i_support = GC_OBJECT(list,OBJECT(bag,_oid_((ClaireObject *) choco.domainSequence->fcall(((int) g0185)))));
                          for (START(i_support); NEXT(i);)
                          { GC_LOOP;
                            if (v == (*(l))[(i+c->cste)])
                             { g0195UU = Kernel.ctrue;
                              break;} 
                            GC_UNLOOP;} 
                          } 
                        } 
                    V_CL0194 = boolean_I_any(g0195UU);
                    } 
                  
                  g0193UU=_oid_(V_CL0194);} 
                g0192I = not_any(g0193UU);
                } 
              
              if (g0192I == CTRUE) (*choco.removeVal)(_oid_(valueVar),
                  v,
                  c->idx2,
                  GC_OID(_oid_(palm_clone_Explanation(e))));
                } 
            v= choco.getNextValue->fcall(((int) g0181),((int) v));
            GC_UNLOOP;} 
          } 
        } 
      else { OID gc_local;
          ITERATE(v);
          bag *v_support;
          v_support = GC_OBJECT(list,OBJECT(bag,_oid_((ClaireObject *) choco.domainSequence->fcall(((int) g0181)))));
          for (START(v_support); NEXT(v);)
          { GC_LOOP;
            { ClaireBoolean * g0196I;
              { OID  g0197UU;
                { ClaireBoolean * V_CL0198;{ OID  g0199UU;
                    { IntVar * g0186 = indexVar;
                      AbstractIntDomain * g0187 = GC_OBJECT(AbstractIntDomain,g0186->bucket);
                      if (g0187 == (NULL))
                       { int  i = g0186->inf->latestValue;
                        { OID gc_local;
                          g0199UU= _oid_(CFALSE);
                          while ((i <= g0186->sup->latestValue))
                          { // HOHO, GC_LOOP not needed !
                            if (v == (*(l))[(i+c->cste)])
                             { g0199UU = Kernel.ctrue;
                              break;} 
                            i= ((g0186->inf->latestValue <= (i+1)) ?
                              (i+1) :
                              g0186->inf->latestValue );
                            } 
                          } 
                        } 
                      else if (INHERIT(g0187->isa,choco._LinkedListIntDomain))
                       { int  i = g0186->inf->latestValue;
                        { OID gc_local;
                          g0199UU= _oid_(CFALSE);
                          while ((i <= g0186->sup->latestValue))
                          { // HOHO, GC_LOOP not needed !
                            if (v == (*(l))[(i+c->cste)])
                             { g0199UU = Kernel.ctrue;
                              break;} 
                            i= choco.getNextValue->fcall(((int) g0187),((int) i));
                            } 
                          } 
                        } 
                      else { OID gc_local;
                          ITERATE(i);
                          g0199UU= _oid_(CFALSE);
                          bag *i_support;
                          i_support = GC_OBJECT(list,OBJECT(bag,_oid_((ClaireObject *) choco.domainSequence->fcall(((int) g0187)))));
                          for (START(i_support); NEXT(i);)
                          { GC_LOOP;
                            if (v == (*(l))[(i+c->cste)])
                             { g0199UU = Kernel.ctrue;
                              break;} 
                            GC_UNLOOP;} 
                          } 
                        } 
                    V_CL0198 = boolean_I_any(g0199UU);
                    } 
                  
                  g0197UU=_oid_(V_CL0198);} 
                g0196I = not_any(g0197UU);
                } 
              
              if (g0196I == CTRUE) (*choco.removeVal)(_oid_(valueVar),
                  v,
                  c->idx2,
                  GC_OID(_oid_(palm_clone_Explanation(e))));
                } 
            GC_UNLOOP;} 
          } 
        } 
    } 
  GC_UNBIND;} 


// v0.29: The constraint must enforce that valueVar takes a value among l, which may be a sequence of values with holes.
// When valueVar is represented as an enumeration of values (with v.bucket), this is enforced from the start
// (when the constraint is posted).
// otherwise, when valueVar is only reperesented by its domain bounds, each time a value is removed from its domain
// we need not only to restrict indexVar, but also to propagate back the new bounds for valueVar.
// Thus, the consequences of this function on indexVar must be posted and propagated back to the PalmElt constraint
// therefore, we replace the cause of the event on indexVar (c.idx1) by 0 => the PalmElt constraint will be re-awaken later
// with a call to updateValueFromIndex which will recompute the min/max for valueVar
/* The c++ function for: updateIndexFromValue(c:PalmElt) [] */
void  palm_updateIndexFromValue_PalmElt(PalmElt *c)
{ GC_RESERVE(1);  // HOHO v3.0.55 optim !
  { list * l = GC_OBJECT(list,c->lval);
    int  n = l->length;
    IntVar * indexVar = GC_OBJECT(IntVar,c->v1);
    IntVar * valueVar = GC_OBJECT(IntVar,c->v2);
    int  minFeasibleIndex = ((indexVar->inf->latestValue <= (1-c->cste)) ?
      (1-c->cste) :
      indexVar->inf->latestValue );
    int  maxFeasibleIndex = (((n-c->cste) <= indexVar->sup->latestValue) ?
      (n-c->cste) :
      indexVar->sup->latestValue );
    int  thecause = ((get_property(choco.bucket,valueVar) != CNULL) ?
      c->idx1 :
      0 );
    Explanation * e;
    { { Explanation * _CL_obj = ((Explanation *) GC_OBJECT(Explanation,new_object_class(palm._Explanation)));
        e = _CL_obj;
        } 
      GC_OBJECT(Explanation,e);} 
    palm_self_explain_AbstractConstraint(c,e);
    palm_self_explain_PalmIntVar1(((PalmIntVar *) valueVar),4,e);
    { OID gc_local;
      while ((((OBJECT(ClaireBoolean,(*choco.canBeInstantiatedTo)(_oid_(indexVar),
          minFeasibleIndex))) == CTRUE) && 
          (not_any((*choco.canBeInstantiatedTo)(_oid_(valueVar),
            (*(l))[(minFeasibleIndex+c->cste)])) == CTRUE)))
      { // HOHO, GC_LOOP not needed !
        ++minFeasibleIndex;
        } 
      } 
    (*choco.updateInf)(_oid_(indexVar),
      minFeasibleIndex,
      thecause,
      GC_OID(_oid_(palm_clone_Explanation(e))));
    { OID gc_local;
      while ((((OBJECT(ClaireBoolean,(*choco.canBeInstantiatedTo)(_oid_(indexVar),
          maxFeasibleIndex))) == CTRUE) && 
          (not_any((*choco.canBeInstantiatedTo)(_oid_(valueVar),
            (*(l))[(maxFeasibleIndex+c->cste)])) == CTRUE)))
      { // HOHO, GC_LOOP not needed !
        maxFeasibleIndex= (maxFeasibleIndex-1);
        } 
      } 
    (*choco.updateSup)(_oid_(indexVar),
      maxFeasibleIndex,
      thecause,
      GC_OID(_oid_(palm_clone_Explanation(e))));
    if (get_property(choco.bucket,indexVar) != CNULL)
     { int  i = (minFeasibleIndex+1);
      int  g0200 = (maxFeasibleIndex-1);
      { OID gc_local;
        while ((i <= g0200))
        { GC_LOOP;
          if (((OBJECT(ClaireBoolean,(*choco.canBeInstantiatedTo)(_oid_(indexVar),
              i))) == CTRUE) && 
              (not_any((*choco.canBeInstantiatedTo)(_oid_(valueVar),
                (*(l))[(i+c->cste)])) == CTRUE))
           { Explanation * erem;
            { { Explanation * _CL_obj = ((Explanation *) GC_OBJECT(Explanation,new_object_class(palm._Explanation)));
                erem = _CL_obj;
                } 
              GC_OBJECT(Explanation,erem);} 
            palm_self_explain_AbstractConstraint(c,erem);
            palm_self_explain_PalmIntVar2(((PalmIntVar *) valueVar),3,(*(l))[(i+c->cste)],erem);
            (*choco.removeVal)(_oid_(indexVar),
              i,
              thecause,
              _oid_(erem));
            } 
          ++i;
          GC_UNLOOP;} 
        } 
      } 
    } 
  GC_UNBIND;} 


// v0.9907: at initialization time, we propagate once for good the fact that:
//   - indices must be in the right range for accessing the integer table 
//   - all values in the domain of valueVar must correspond to a value in l 
/* The c++ function for: choco/awake(c:PalmElt) [] */
void  choco_awake_PalmElt_palm(PalmElt *c)
{ GC_BIND;
  { list * l = GC_OBJECT(list,c->lval);
    int  n = c->lval->length;
    int  o = c->cste;
    IntVar * indexVar = GC_OBJECT(IntVar,c->v1);
    IntVar * valueVar = GC_OBJECT(IntVar,c->v2);
    Explanation * e;
    { { Explanation * _CL_obj = ((Explanation *) GC_OBJECT(Explanation,new_object_class(palm._Explanation)));
        e = _CL_obj;
        } 
      GC_OBJECT(Explanation,e);} 
    palm_self_explain_AbstractConstraint(c,e);
    (*choco.updateInf)(_oid_(indexVar),
      (1-o),
      c->idx1,
      GC_OID(_oid_(palm_clone_Explanation(e))));
    (*choco.updateSup)(_oid_(indexVar),
      (n-o),
      c->idx1,
      GC_OID(_oid_(palm_clone_Explanation(e))));
    choco_propagate_PalmElt(c);
    } 
  ;GC_UNBIND;} 


/* The c++ function for: choco/propagate(c:PalmElt) [] */
void  choco_propagate_PalmElt(PalmElt *c)
{ palm_updateIndexFromValue_PalmElt(c);
  palm_updateValueFromIndex_PalmElt(c);
  } 


/* The c++ function for: choco/awakeOnInf(c:PalmElt,idx:integer) [] */
void  choco_awakeOnInf_PalmElt(PalmElt *c,int idx)
{ if (idx == 1)
   palm_updateValueFromIndex_PalmElt(c);
  else palm_updateIndexFromValue_PalmElt(c);
    } 


/* The c++ function for: choco/awakeOnSup(c:PalmElt,idx:integer) [] */
void  choco_awakeOnSup_PalmElt(PalmElt *c,int idx)
{ if (idx == 1)
   palm_updateValueFromIndex_PalmElt(c);
  else palm_updateIndexFromValue_PalmElt(c);
    } 


/* The c++ function for: choco/awakeOnInst(c:PalmElt,idx:integer) [] */
void  choco_awakeOnInst_PalmElt(PalmElt *c,int idx)
{ if (idx == 1) 
  { choco_instantiate_IntVar2(GC_OBJECT(IntVar,c->v2),(*(c->lval))[(c->v1->value+c->cste)],c->idx2);
     } 
  else{ GC_BIND;
    palm_updateIndexFromValue_PalmElt(c);
    GC_UNBIND;} 
  } 


// v0.33 <thb>: in case a value is no longer feasible, we need to upate the index.
// Note that we call updateIndexFrom Value rather than only removing the i such that l[i]=x
// from the domain of the index variable.
// This is due to the case of interval approximation for value Var (in this case,
// one single call to updateIndexFromValue reaches fix point saturation)
/* The c++ function for: choco/awakeOnRem(c:PalmElt,idx:integer,x:integer) [] */
void  choco_awakeOnRem_PalmElt(PalmElt *c,int idx,int x)
{ if (idx == 1)
   palm_updateValueFromIndex_PalmElt(c);
  else palm_updateIndexFromValue_PalmElt(c);
    } 


//all restorations have the same behavior
/* The c++ function for: awakeOnRestore(c:PalmElt,idx:integer) [] */
void  palm_awakeOnRestore_PalmElt(PalmElt *c,int idx)
{ GC_BIND;
  { int  n = c->lval->length;
    int  o = c->cste;
    IntVar * indexVar = GC_OBJECT(IntVar,c->v1);
    Explanation * e;
    { { Explanation * _CL_obj = ((Explanation *) GC_OBJECT(Explanation,new_object_class(palm._Explanation)));
        e = _CL_obj;
        } 
      GC_OBJECT(Explanation,e);} 
    palm_self_explain_AbstractConstraint(c,e);
    (*choco.updateInf)(_oid_(indexVar),
      (1-o),
      c->idx1,
      GC_OID(_oid_(palm_clone_Explanation(e))));
    (*choco.updateSup)(_oid_(indexVar),
      (n-o),
      c->idx1,
      GC_OID(_oid_(palm_clone_Explanation(e))));
    } 
  if (idx == 1)
   palm_updateIndexFromValue_PalmElt(c);
  else palm_updateValueFromIndex_PalmElt(c);
    GC_UNBIND;} 


/* The c++ function for: awakeOnRestoreInf(c:PalmElt,idx:integer) [] */
void  palm_awakeOnRestoreInf_PalmElt(PalmElt *c,int idx)
{ palm_awakeOnRestore_PalmElt(c,idx);
  } 


/* The c++ function for: awakeOnRestoreSup(c:PalmElt,idx:integer) [] */
void  palm_awakeOnRestoreSup_PalmElt(PalmElt *c,int idx)
{ palm_awakeOnRestore_PalmElt(c,idx);
  } 


/* The c++ function for: awakeOnRestoreVal(c:PalmElt,idx:integer,v:integer) [] */
void  palm_awakeOnRestoreVal_PalmElt(PalmElt *c,int idx,int v)
{ palm_awakeOnRestore_PalmElt(c,idx);
  } 


//v0.93: askIfEntailed can be called before any awake (in bool combinations)
//       Therefore we cannot assume that all values of domain(indexVar) lead to "in scope" indexes for the list.
//       -> added tests (idx + c.cste) % (1 .. length(l))
/* The c++ function for: choco/askIfEntailed(c:PalmElt) [] */
OID  choco_askIfEntailed_PalmElt(PalmElt *c)
{ GC_BIND;
  { OID Result = 0;
    { list * l = c->lval;
      IntVar * indexVar = c->v1;
      IntVar * valueVar = c->v2;
      { ClaireBoolean * g0205I;
        { ClaireBoolean *v_and;
          { v_and = OBJECT(ClaireBoolean,_oid_((ClaireObject *) choco.isInstantiated->fcall(((int) valueVar))));
            if (v_and == CFALSE) g0205I =CFALSE; 
            else { { OID  g0206UU;
                { IntVar * g0201 = indexVar;
                  AbstractIntDomain * g0202 = g0201->bucket;
                  if (g0202 == (NULL))
                   { int  idx = g0201->inf->latestValue;
                    { OID gc_local;
                      g0206UU= _oid_(CFALSE);
                      while ((idx <= g0201->sup->latestValue))
                      { // HOHO, GC_LOOP not needed !
                        if ((((idx+c->cste) > l->length) || 
                              (1 > (idx+c->cste))) || 
                            ((*(l))[(idx+c->cste)] != valueVar->value))
                         { g0206UU = Kernel.ctrue;
                          break;} 
                        idx= ((g0201->inf->latestValue <= (idx+1)) ?
                          (idx+1) :
                          g0201->inf->latestValue );
                        } 
                      } 
                    } 
                  else if (INHERIT(g0202->isa,choco._LinkedListIntDomain))
                   { int  idx = g0201->inf->latestValue;
                    { OID gc_local;
                      g0206UU= _oid_(CFALSE);
                      while ((idx <= g0201->sup->latestValue))
                      { // HOHO, GC_LOOP not needed !
                        if ((((idx+c->cste) > l->length) || 
                              (1 > (idx+c->cste))) || 
                            ((*(l))[(idx+c->cste)] != valueVar->value))
                         { g0206UU = Kernel.ctrue;
                          break;} 
                        idx= choco.getNextValue->fcall(((int) g0202),((int) idx));
                        } 
                      } 
                    } 
                  else { OID gc_local;
                      ITERATE(idx);
                      g0206UU= _oid_(CFALSE);
                      bag *idx_support;
                      idx_support = GC_OBJECT(list,OBJECT(bag,_oid_((ClaireObject *) choco.domainSequence->fcall(((int) g0202)))));
                      for (START(idx_support); NEXT(idx);)
                      { GC_LOOP;
                        if ((((idx+c->cste) > l->length) || 
                              (1 > (idx+c->cste))) || 
                            ((*(l))[(idx+c->cste)] != valueVar->value))
                         { g0206UU = Kernel.ctrue;
                          break;} 
                        GC_UNLOOP;} 
                      } 
                    } 
                v_and = not_any(g0206UU);
                } 
              if (v_and == CFALSE) g0205I =CFALSE; 
              else g0205I = CTRUE;} 
            } 
          } 
        
        if (g0205I == CTRUE) Result = Kernel.ctrue;
          else { ClaireBoolean * g0207I;
          { OID  g0208UU;
            { IntVar * g0203 = indexVar;
              AbstractIntDomain * g0204 = g0203->bucket;
              if (g0204 == (NULL))
               { int  idx = g0203->inf->latestValue;
                { OID gc_local;
                  g0208UU= _oid_(CFALSE);
                  while ((idx <= g0203->sup->latestValue))
                  { // HOHO, GC_LOOP not needed !
                    if ((((idx+c->cste) <= l->length) && 
                          (1 <= (idx+c->cste))) && 
                        ((OBJECT(ClaireBoolean,(*choco.canBeInstantiatedTo)(_oid_(valueVar),
                          (*(l))[(idx+c->cste)]))) == CTRUE))
                     { g0208UU = Kernel.ctrue;
                      break;} 
                    idx= ((g0203->inf->latestValue <= (idx+1)) ?
                      (idx+1) :
                      g0203->inf->latestValue );
                    } 
                  } 
                } 
              else if (INHERIT(g0204->isa,choco._LinkedListIntDomain))
               { int  idx = g0203->inf->latestValue;
                { OID gc_local;
                  g0208UU= _oid_(CFALSE);
                  while ((idx <= g0203->sup->latestValue))
                  { // HOHO, GC_LOOP not needed !
                    if ((((idx+c->cste) <= l->length) && 
                          (1 <= (idx+c->cste))) && 
                        ((OBJECT(ClaireBoolean,(*choco.canBeInstantiatedTo)(_oid_(valueVar),
                          (*(l))[(idx+c->cste)]))) == CTRUE))
                     { g0208UU = Kernel.ctrue;
                      break;} 
                    idx= choco.getNextValue->fcall(((int) g0204),((int) idx));
                    } 
                  } 
                } 
              else { OID gc_local;
                  ITERATE(idx);
                  g0208UU= _oid_(CFALSE);
                  bag *idx_support;
                  idx_support = GC_OBJECT(list,OBJECT(bag,_oid_((ClaireObject *) choco.domainSequence->fcall(((int) g0204)))));
                  for (START(idx_support); NEXT(idx);)
                  { GC_LOOP;
                    if ((((idx+c->cste) <= l->length) && 
                          (1 <= (idx+c->cste))) && 
                        ((OBJECT(ClaireBoolean,(*choco.canBeInstantiatedTo)(_oid_(valueVar),
                          (*(l))[(idx+c->cste)]))) == CTRUE))
                     { g0208UU = Kernel.ctrue;
                      break;} 
                    GC_UNLOOP;} 
                  } 
                } 
            g0207I = boolean_I_any(g0208UU);
            } 
          
          if (g0207I == CTRUE) Result = CNULL;
            else Result = Kernel.cfalse;
          } 
        } 
      } 
    GC_UNBIND; return (Result);} 
  } 


/* The c++ function for: choco/testIfSatisfied(c:PalmElt) [] */
ClaireBoolean * choco_testIfSatisfied_PalmElt(PalmElt *c)
{ ;return (equal((*(c->lval))[(c->v1->value+c->cste)],c->v2->value));} 


/* The c++ function for: whyTrueOrFalse(c:PalmElt) [] */
set * palm_whyTrueOrFalse_PalmElt(PalmElt *c)
{ GC_BIND;
  { set *Result ;
    { Explanation * expl;
      { { Explanation * _CL_obj = ((Explanation *) GC_OBJECT(Explanation,new_object_class(palm._Explanation)));
          expl = _CL_obj;
          } 
        GC_OBJECT(Explanation,expl);} 
      palm_self_explain_PalmIntVar1(GC_OBJECT(PalmIntVar,((PalmIntVar *) c->v1)),4,expl);
      palm_self_explain_PalmIntVar1(GC_OBJECT(PalmIntVar,((PalmIntVar *) c->v2)),4,expl);
      Result = expl->explanation;
      } 
    GC_UNBIND; return (Result);} 
  } 


/* The c++ function for: whyIsFalse(c:PalmElt) [] */
set * palm_whyIsFalse_PalmElt(PalmElt *c)
{ return (palm_whyTrueOrFalse_PalmElt(c));} 


/* The c++ function for: whyIsTrue(c:PalmElt) [] */
set * palm_whyIsTrue_PalmElt(PalmElt *c)
{ return (palm_whyTrueOrFalse_PalmElt(c));} 


/* The c++ function for: checkPalm(ct:PalmElt) [] */
ClaireBoolean * palm_checkPalm_PalmElt(PalmElt *ct)
{ return (CTRUE);} 


// v0.34
// claire3 port register no longer used