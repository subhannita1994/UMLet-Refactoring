// Implémentation d'un système d'explication en claire/choco
// (c) 2001 - Narendra Jussien - EMN
// Système PaLM 


// ** Summary : Basic constraints and handling mechanisms
// Part 1 : Complete all-diff (Régin implementation ...)
// Part 2 : Permutation constraint (dual representation of variables and values)
//              Permutation(x,y) <=> (x_i = j <=> y_j = i)
// Part 3 : GCC constraint
// Part 4 : GCCVar constraint
// Part 5 : Occur (nb of occurrence of a value (possibly an IntVar) in a list of vars
//			a tool for atleast, atmost, ...
// Part 6 : Element (correspondance between variables and indices in a list)

claire/ALLDIFF_PRECISE_EXPLANATIONS: boolean := true // 

// *************************************************************
// * Part 1 : ALLDIFFERENT constraint (Régin implementation)   *
// *************************************************************

PalmCompleteAllDiff <: ice/CompleteAllDiff() // A PaLM version of the choco CompleteAllDiff
[self_print(c:PalmCompleteAllDiff)
 -> printf("e-allDifferent(~S)", list{x | x in c.vars})]
	
// API entry point: creating the constraint (before posting it)
[claire/e-allDifferent(l1:list[PalmIntVar]) : PalmCompleteAllDiff => claire/e-completeAllDiff(l1)]
[claire/e-completeAllDiff(l1:list[PalmIntVar]) : PalmCompleteAllDiff
 -> let n := length(l1), c := PalmCompleteAllDiff() in
      (for v in l1
         (c.minValue :min getInf(v), c.maxValue :max getSup(v)),
       c.vars := copy(l1) as list<IntVar>, 
       closeLargeIntConstraint(c),
       c.nbLeftVertices := n, c.nbRightVertices := c.maxValue - c.minValue + 1,
       closeAssignmentConstraint(c),
	   initHook(c), 
       c)]

// the event generated by the flow algorithm: discovering that an edge is no longer valid,
// and posting this event to all constraints but the current one
// (since we are already achieving consistency in one single loop)
[deleteEdgeAndPublish(c:PalmCompleteAllDiff,i:integer,j:integer) : void
 -> assert(1 <= i & i <= c.nbLeftVertices & 1 <= j & j <= c.nbRightVertices),
    deleteMatch(c,i,j),
	let expl := Explanation(),     ; explTest := Explanation(),
		n1 := c.nbLeftVertices,
		n2 := c.nbRightVertices,
		compi := c.component[i],
		compj := c.component[j + n1],
		comps := c.component[c.source]
	in ( 
		self_explain(c, expl),  ; self_explain(c, explTest), 
		if (ALLDIFF_PRECISE_EXPLANATIONS) (
			assert(read(c.componentOrder,compi,compj)), 
			for i2 in (1 .. n1)
				let compi2 := c.component[i2]
				in (
					if (read(c.componentOrder,compi,compi2)) (
						for j2 in (1 .. n2) 
							let compj2 := c.component[j2 + n1]
							in (
								if read(c.componentOrder, compj2, compj) (
									self_explain(c.vars[i2], VAL, j2 + c.minValue - 1, expl)
								)
							)
					)
				),
			// handling the source particular case (source in j past)
			if (read(c.componentOrder, comps, compj)) (
				for j2 in (1 .. n2) // values
					let compj2 := c.component[j2 + n1],
						i2 := inverseMatch(c, j2)
					in (	
						if ((i2 != 0) & read(c.componentOrder, compi, compj2)) (
							for k in (1 .. n2) (// all values
								let compk := c.component[k + n1]
								in (
									if (compk != compj2) (
										self_explain(c.vars[i2], VAL, k + c.minValue - 1, expl)
									)
								)
							)
						)
					)
			),
			// handling the source particular case (source in i future)
			if read(c.componentOrder, compi, comps) (
				for j2 in (1 .. n2) // values
					let compj2 := c.component[j2 + n1],
						i2 := inverseMatch(c, j2)
					in (
						if ((i2 = 0) & read(c.componentOrder, compj2, compj)) (
							for k in (1 .. n1) // all variables
								let compk := c.component[k] 
								in (
									if (compk = compj2) (
										self_explain(c.vars[k], DOM, expl)
									)
								)
				 		)
					)
			)
		)
		else 
			for v in c.vars self_explain(v, DOM, expl),
;		for v in c.vars self_explain(v, DOM, explTest),
;		if (size(expl.explanation) < size(explTest.explanation))
;			printf("**** !!!! **** ~S < ~S \n",size(expl.explanation),size(explTest.explanation)),
		removeVal(c.vars[i], j + c.minValue - 1, c.indices[i], expl)
	)]

[updateDataStructuresOnConstraint(c: PalmCompleteAllDiff, idx: integer, way: SELECT, val: integer, unused: integer) : void
 -> deleteMatch(c, idx, val - c.minValue + 1),
	constAwake(c, false)]

[updateDataStructuresOnRestoreConstraint(c: PalmCompleteAllDiff, idx: integer, way: SELECT, val: integer, unused: integer) : void
 -> let n1 := c.nbLeftVertices
	in (
		if ((c.matchingSize < n1) |  (c.component[idx] != c.component[val - c.minValue + 1 + n1]))
			constAwake(c, false)
	)]

// propagation functions: reacting to events
[awakeOnRem(c:PalmCompleteAllDiff,idx:integer,val:integer) : void
 -> nil ]

[awakeOnRestoreVal(c:PalmCompleteAllDiff,idx:integer,val:integer) : void
 -> nil ]

// no specific initial propagation (awake does the same job as propagate)
[awake(c:PalmCompleteAllDiff) : void
 -> // [0] awake(c:PalmCompleteAllDiff) called,
 	propagate(c),
 	// [0] awake(c:PalmCompleteAllDiff) done,
 	nil
]

[checkPalm(ct: PalmCompleteAllDiff) : boolean -> true]
// claire3 port register no longer used
;;(#if (compiler.active? & compiler.loading?) register(PalmCompleteAllDiff))


// *************************************************************
// * Part 2 : PERMUTATION constraint                           *
// *************************************************************


// the constraint uses two lists of integer valued variables and models
// a permutation (and the inverse permutation) over (1 .. n)
PalmPermutation <: ice/Permutation()
[self_print(c:PalmPermutation)
 -> printf("e-permutation(~S,~S)",
           list{c.vars[i] | i in (1 .. c.nbLeftVertices)},
           list{c.vars[i + c.nbLeftVertices] | i in (1 .. c.nbRightVertices)})]


// API entry point: creating the constraint (before posting it)
[claire/e-permutation(l1:list[PalmIntVar], l2:list[PalmIntVar]) : PalmPermutation
 -> let c := PalmPermutation(), n := length(l1) in
      (c.vars := (list<IntVar>{v | v in l1} /+ list<IntVar>{v | v in l2}),
       closeLargeIntConstraint(c),
       c.nbLeftVertices := n, c.nbRightVertices := n,
	   c.minValue := 1, c.maxValue := n, 
       closeAssignmentConstraint(c),
	   initHook(c), 
       c)]





[deleteEdgeAndPublish(c:PalmPermutation,i:integer,j:integer) : void
 -> assert(1 <= i & i <= c.nbLeftVertices & 1 <= j & j <= c.nbRightVertices),
    let n1 := c.nbLeftVertices,
		n2 := c.nbRightVertices,
		compi := c.component[i],
		compj := c.component[j + n1]
	in (
		deleteMatch(c,i,j),
		let expl := Explanation() 
		in ( 
			self_explain(c, expl),
			for v in c.vars self_explain(v, DOM, expl),

;			for i2 in (1 .. n1)
;				let compi2 := c.component[i2]
;				in (
;					if ((compi != compi2) & read(c.componentOrder,compi,compi2)) (
;						for j2 in (1 .. n2) 
;							let compj2 := c.component[j2 + n1]
;							in (
;								if read(c.componentOrder, compj2, compj) (
;									self_explain(c.vars[i2], VAL, j2, expl)
;								)
;							)
;					)
;				),

			removeVal(c.vars[i],j,c.indices[i], clone(expl)),
			removeVal(c.vars[n1 + j],i,c.indices[n1 + j], clone(expl))
		)
	)]


[publishDeletion(c: PalmPermutation, i: integer, j: integer, fromLeft: boolean)
 -> let n1 := c.nbLeftVertices, 
		n2 := c.nbRightVertices 
	in (
		if fromLeft removeVal(c.vars[j + n1],i,c.indices[j + n1], becauseOf(c, theHole(c.vars[i], j)))   
		else removeVal(c.vars[i],j,c.indices[i], becauseOf(c, theHole(c.vars[j + n1], i))) 
	)]


[updateDataStructuresOnConstraint(c: PalmPermutation, idx: integer, way: SELECT, val: integer, unused: integer) : void
 -> let n := c.nbLeftVertices 
	in (
		if (idx <= n)
            deleteMatch(c,idx,val)
        else (
			idx :- n,
            deleteMatch(c,val,idx)
		)
	),
    constAwake(c,false)]

[updateDataStructuresOnRestoreConstraint(c: PalmPermutation, idx: integer, way: SELECT, val: integer, unused: integer) : void
 -> let n := c.nbLeftVertices
 	in (
		if (idx <= n) (
			
            if ((c.matchingSize < n) | (c.component[idx] != c.component[val + n])) 
				constAwake(c, false)
		)
        else (
			if ((c.matchingSize < n) |  (c.component[val] != c.component[idx]))
				 constAwake(c, false)
		)
	)]


// propagation functions: reacting to events
[awakeOnRem(c:PalmPermutation,idx:integer,val:integer) : void
 -> let n := c.nbLeftVertices 
	in ( if (idx <= c.nbLeftVertices)
            publishDeletion(c,idx,val,true)
         else (
			idx :- n,
            publishDeletion(c,val,idx,false)
		)
	)]


[awakeOnRestoreVal(c: PalmPermutation, idx: integer, val: integer) : void
 -> nil]

// performing the initial propagation
[awake(c:PalmPermutation) : void
  -> // [0] awake(c:PalmPermutation) called,
     let n := c.nbLeftVertices,
		 expl := Explanation()
	 in (
		self_explain(c, expl),
		for i in (1 .. n) (
			updateInf(c.vars[i],1,c.indices[i], clone(expl)),
            updateSup(c.vars[i],n,c.indices[i], clone(expl))
		),
		for j in (1 .. n) (
			updateInf(c.vars[j + n],1,c.indices[j + n], clone(expl)),
			updateSup(c.vars[j + n],n,c.indices[j + n], clone(expl))
		),
		for i in (1 .. n)
			 for j in (1 .. n) (	
				if not(choco/canBeInstantiatedTo(c.vars[i],j)) 
	               removeVal(c.vars[j + n],i,c.indices[j + n], becauseOf(c, theHole(c.vars[i], j))),
				if not(choco/canBeInstantiatedTo(c.vars[j + n],i))
				   removeVal(c.vars[i],j,c.indices[i],becauseOf(c, theHole(c.vars[j + n], i)))
		),
		propagate(c)),
		// [0] awake(c:PalmPermutation) done,
		nil
]

[checkPalm(ct: PalmPermutation) : boolean -> true]
// claire3 port register no longer used
;;(#if (compiler.active? & compiler.loading?) register(PalmPermutation))


// *************************************************************
// * Part 3 : GCC constraint                                   *
// *************************************************************

// a very simple version of the cardinality constraint 
PalmGlobalCardinality <: ice/GlobalCardinality()
[self_print(c:PalmGlobalCardinality)
 -> printf("e-gcc(~S,[(~S..~S)", c.vars, c.minFlow[1], c.maxFlow[1]),
	for i in (2 .. length(c.minFlow))
		printf(",(~S..~S)", c.minFlow[i], c.maxFlow[i]),
	printf("])")]

// API entry point: creating the constraint (before posting it)
[e-gcc(l1:list[PalmIntVar], l2:list[Interval]) : PalmGlobalCardinality -> e-gcc(l1,1,length(l2),l2)]
[e-gcc(l1:list[PalmIntVar], val1:integer, val2:integer, l2:list[Interval]) : PalmGlobalCardinality
 -> let c := PalmGlobalCardinality() 
	in (
		c.vars := copy(l1) as list<IntVar>,
		closeLargeIntConstraint(c),
		c.minValue := val1,
		c.maxValue := val2,
		c.nbRightVertices := val2 - val1 + 1,
		assert(length(l2) = c.nbRightVertices),
		c.nbLeftVertices := length(l1),
		c.minFlow := make_array(length(l2), integer, 0),
		c.maxFlow := make_array(length(l2), integer, 0),
		c.flow := make_array(length(l2), integer, 0),
		for i in (1 .. length(l2)) (
			c.minFlow[i] := l2[i].arg1, 
			c.maxFlow[i] := l2[i].arg2
		),
		closeAssignmentConstraint(c),
		initHook(c),
		c)]

// The next two functions implement the main event:
// when an edge is definitely removed from the bipartite assignment graph.
[deleteEdgeAndPublish(c:PalmGlobalCardinality,i:integer,j:integer) : void
 -> assert(1 <= i & i <= c.nbLeftVertices & 1 <= j & j <= c.nbRightVertices),
    deleteMatch(c,i,j),
	let expl := Explanation(),
		n1 := c.nbLeftVertices,
		n2 := c.nbRightVertices,
		compi := c.component[i],
		compj := c.component[j + n1]
	in (
		self_explain(c, expl),
;		for v in c.vars self_explain(v, DOM, expl),
		for i2 in (1 .. n1)
			let compi2 := c.component[i2]
			in (
				if ((compi != compi2) & read(c.componentOrder,compi,compi2)) (
					for j2 in (1 .. n2) 
						let compj2 := c.component[j2 + n1]
						in (
							if read(c.componentOrder, compj2, compj) (
;								// [0] expl: ~S ~S // c.vars[i2], j2 + c.minValue - 1, 
								self_explain(c.vars[i2], VAL, j2 + c.minValue - 1, expl)
							)
						)
				)
			),

		removeVal(c.vars[i], j + c.minValue - 1, c.indices[i],expl)
	)]

[updateDataStructuresOnConstraint(c: PalmGlobalCardinality, idx: integer, way: SELECT, val: integer, unused: integer) : void
 -> deleteMatch(c, idx, val - c.minValue + 1),
	constAwake(c, false)]

[updateDataStructuresOnRestoreConstraint(c: PalmGlobalCardinality, idx: integer, way: SELECT, val: integer, unused: integer) : void
 -> let n1 := c.nbLeftVertices
	in (
		if ((c.matchingSize < n1) |  (c.component[idx] != c.component[val - c.minValue + 1 + n1]))
			constAwake(c, false)
	)]

[awakeOnRem(c:PalmGlobalCardinality,idx:integer,val:integer) : void
 -> nil]

[awakeOnRestoreVal(c: PalmGlobalCardinality, idx: integer, val: integer) : void
 -> nil]


[awake(c:PalmGlobalCardinality) : void
 -> // [0] awake(c:PalmGlobalCardinality) called,
 	for i in (1 .. c.nbLeftVertices) (
		updateInf(c.vars[i],c.minValue,c.indices[i],becauseOf(c)),
        updateSup(c.vars[i],c.maxValue,c.indices[i],becauseOf(c))
	),
    propagate(c),
    // [0] awake(c:PalmGlobalCardinality) done,
    nil
]

 
[checkPalm(ct: PalmGlobalCardinality) : boolean -> true]
// claire3 port register no longer used
;;(#if (compiler.active? & compiler.loading?) register(PalmGlobalCardinality))

// *************************************************************
// * Part 4 : GCCVAR constraint                                *
// *************************************************************

// Il faut sûrement réécrire augmentFlow car il ne faut pas qu'une 
// contradiction choco soit levée !!! 

// a less simple version of the GCC constraint
PalmGlobalCardinalityVar <: PalmGlobalCardinality(
	intervals: list<PalmIntVar>
)

[self_print(c:PalmGlobalCardinalityVar)
 -> printf("e-gcc(~S,~S)",
           list{c.vars[i] | i in (1 .. c.nbLeftVertices)},
           list{c.vars[i + c.nbLeftVertices] | i in (1 .. c.nbRightVertices)})]


// API entry point: creating the constraint (before posting it)
[e-gcc(l1:list[PalmIntVar], l2:list[PalmIntVar]) : PalmGlobalCardinalityVar -> e-gcc(l1,1,length(l2),l2)]
[e-gcc(l1:list[PalmIntVar], val1:integer, val2:integer, l2:list[PalmIntVar]) : PalmGlobalCardinalityVar
 -> let c := PalmGlobalCardinalityVar() 
	in (
		c.vars := copy(l1) /+ copy(l2),
		c.intervals := copy(l2),
		closeLargeIntConstraint(c),
		c.minValue := val1,
		c.maxValue := val2,
		c.nbRightVertices := val2 - val1 + 1,
		assert(length(l2) = c.nbRightVertices),
		c.nbLeftVertices := length(l1),
		c.minFlow := make_array(length(l2), integer, 0),
		c.maxFlow := make_array(length(l2), integer, 0),
		c.flow := make_array(length(l2), integer, 0),
		for i in (1 .. length(l2)) (
			c.minFlow[i] := getInf(l2[i]), 
			c.maxFlow[i] := getSup(l2[i])
		),
		closeAssignmentConstraint(c),
		initHook(c),
		c)]


[mustDiminishFlowFromSource(c: PalmGlobalCardinalityVar, j: integer) : boolean
 -> (c.flow[j] > c.maxFlow[j]) ]

[updateDataStructuresOnConstraint(c: PalmGlobalCardinalityVar, idx: integer, way: SELECT, val: integer, unused: integer) : void
 -> if (idx <= c.nbLeftVertices) (
		deleteMatch(c, idx, val - c.minValue + 1),
		constAwake(c, false)
	) else (
		let ridx := idx - c.nbLeftVertices
		in (
			if ((c.minFlow[ridx] < getInf(c.vars[idx])) | (c.maxFlow[ridx] > getSup(c.vars[idx]))) (
				c.minFlow[ridx] := getInf(c.vars[idx]),
				c.maxFlow[ridx] := getSup(c.vars[idx]),
				if (mustGrowFlowFromSource(c, ridx)) (
					constAwake(c, false)
				)
				else if (mustDiminishFlowFromSource(c, ridx)) (
					closeAssignmentConstraint(c), // reset all data structures
					c.flow := make_array(length(c.intervals), integer, 0),
					constAwake(c, false) // restart from scratch ! 
				)
			)
		)
	)]

[updateDataStructuresOnRestoreConstraint(c: PalmGlobalCardinalityVar, idx: integer, way: SELECT, val: integer, unused: integer) : void
 -> let n1 := c.nbLeftVertices
	in (
		if (idx <= n1) (
			if ((c.matchingSize < n1) |  (c.component[idx] != c.component[val - c.minValue + 1 + n1]))
				constAwake(c, false)
		) 
		else (
			let ridx := idx - n1 
			in (
				if ((c.minFlow[ridx] > getInf(c.vars[idx])) | (c.maxFlow[ridx] < getSup(c.vars[idx]))) (
					c.minFlow[ridx] := getInf(c.vars[idx]),
					c.maxFlow[ridx] := getSup(c.vars[idx]),
					constAwake(c, false)
				)
			)
		)
	)]

[awakeOnRem(c:PalmGlobalCardinalityVar,idx:integer,val:integer) : void
 -> nil]

[awakeOnRestoreVal(c: PalmGlobalCardinalityVar, idx: integer, val: integer) : void
 -> nil]


[awake(c:PalmGlobalCardinalityVar) : void
 -> // [0] awake(c:PalmGlobalCardinalityVar) called,
 	for i in (1 .. c.nbLeftVertices) (
		updateInf(c.vars[i],c.minValue,c.indices[i],becauseOf(c)),
        updateSup(c.vars[i],c.maxValue,c.indices[i],becauseOf(c))
	),
    propagate(c),
    // [0] awake(c:PalmGlobalCardinalityVar) done,
    nil
]


[propagate(c: PalmGlobalCardinalityVar) : void 
 -> removeUselessEdges(c),
	// propagating the supplementary variables
	let n1 := c.nbLeftVertices,
		source := c.nbVertices, csource := c.component[source],
		expl := Explanation()
	in (
		self_explain(c, expl),
		for v in c.vars self_explain(v, DOM, expl), 
		for val in (c.minValue .. c.maxValue) (
			if (c.component[val - c.minValue + 1 + n1] != csource) (
				let vassign := c.flow[val - c.minValue + 1], 
					cvar := c.vars[n1 + val - c.minValue + 1],
					cidx := c.indices[n1 + val - c.minValue + 1],
					expl := Explanation()
				in (
					for vi in (domainSequence(cvar.bucket) but vassign)
						removeVal(cvar, vi, cidx, clone(expl))
				)
			)
		)
	)]
[checkPalm(ct: PalmGlobalCardinalityVar) : boolean -> true]
// claire3 port register no longer used
;;(#if (compiler.active? & compiler.loading?) register(PalmGlobalCardinality))


// ***
// * common propagation tool                            
// ***

[ice/augmentFlow(c: PalmCompleteAllDiff) : void
 -> let eopath := findAlternatingPath(c), n1 := c.nbLeftVertices 
	in (
		if (c.matchingSize < n1)
			//[MTALK] current flow of size:~S: ~S // c.matchingSize, list{list(i,match(c,i)) | i in list{i in (1 .. n1) | match(c,i) > 0}},
		while (eopath > 0) (
			augment(c,eopath), 
			eopath := findAlternatingPath(c)
		),
		if (c.matchingSize < n1) (
			assert(exists(i in (1 .. n1) | match(c,i) = 0)),
			//[MTALK] there exists no perfect matching // ,
 			let expl := Explanation() 
			in (
				self_explain(c, expl), 
				for v in c.vars self_explain(v, DOM, expl),
				raisePalmFakeContradiction(getProblem(c).propagationEngine, expl)
			)
		)
		else (
			//[MTALK] found a perfect matching (size:~S) // c.matchingSize,
            checkFlow(c)
		) 
	)]

[ice/augmentFlow(c: PalmPermutation) : void
 -> let eopath := findAlternatingPath(c), n1 := c.nbLeftVertices 
	in (
		if (c.matchingSize < n1)
			//[MTALK] current flow of size:~S: ~S // c.matchingSize, list{list(i,match(c,i)) | i in list{i in (1 .. n1) | match(c,i) > 0}},
		while (eopath > 0) (
			augment(c,eopath), 
			eopath := findAlternatingPath(c)
		),
		if (c.matchingSize < n1) (
			assert(exists(i in (1 .. n1) | match(c,i) = 0)),
			//[MTALK] there exists no perfect matching // ,
 			let expl := Explanation() 
			in (
				self_explain(c, expl), 
				for v in c.vars self_explain(v, DOM, expl),
				raisePalmFakeContradiction(getProblem(c).propagationEngine, expl)
			)
		)
		else (
			//[MTALK] found a perfect matching (size:~S) // c.matchingSize,
            checkFlow(c)
		) 
	)]



[ice/augmentFlow(c: PalmGlobalCardinality) : void
 -> let eopath := findAlternatingPath(c), n1 := c.nbLeftVertices 
	in (
		if (c.matchingSize < n1)
			//[MTALK] current flow of size:~S: ~S // c.matchingSize, list{list(i,match(c,i)) | i in list{i in (1 .. n1) | match(c,i) > 0}},
		while (eopath > 0) (
			augment(c,eopath), 
			eopath := findAlternatingPath(c)
		),
		if (c.matchingSize < n1) (
			assert(exists(i in (1 .. n1) | match(c,i) = 0)),
			//[MTALK] there exists no perfect matching // ,
 			let expl := Explanation() 
			in (
				self_explain(c, expl), 
				for v in c.vars self_explain(v, DOM, expl),
				raisePalmFakeContradiction(getProblem(c).propagationEngine, expl)
			)
		)
		else (
			//[MTALK] found a perfect matching (size:~S) // c.matchingSize,
            checkFlow(c)
		) 
	)]


[removeUselessEdges(c: PalmCompleteAllDiff) : void
 -> assert(c.matchingSize = count(list{i in (1 .. c.nbLeftVertices) | match(c,i) != 0})),
    if (c.matchingSize < c.nbLeftVertices)
       (//[MVIEW] complete reference matching [~S/~S] into a perfect matching // c.matchingSize,c.nbLeftVertices,
        ice/augmentFlow(c))
    else //[MVIEW] reference matching already a perfect matching //,
    let n1 := c.nbLeftVertices, n2 := c.nbRightVertices in
      (//[MVIEW] compute strongly connected components decomposition //,
       firstPassDFS(c), secondPassDFS(c),
       //[MVIEW] remove edges connecting different SCC //,
       for i in (1 .. n1) 
          //[MTALK] left vertex ~S: scc:~S // i,c.component[i],
       for j in (1 .. n2)
          //[MTALK] right vertex ~S: scc:~S // j,c.component[j + n1],
       let nkept := 0, ndiscard := 0 in
          (for i in (1 .. c.nbLeftVertices)
              for j in (mayMatch(c,i) but match(c,i))
                 (if (c.component[i] != c.component[j + n1])
                     (//[MTALK] discard edge ~S ~S // i,j,
                      ndiscard :+ 1,
                      deleteEdgeAndPublish(c,i,j))
                  else nkept :+ 1),
           //[MVIEW] alldiff SCC decomposition: ~S edges kept, ~S discarded // nkept,ndiscard
           ) )]

[removeUselessEdges(c: PalmPermutation) : void
 -> assert(c.matchingSize = count(list{i in (1 .. c.nbLeftVertices) | match(c,i) != 0})),
    if (c.matchingSize < c.nbLeftVertices)
       (//[MVIEW] complete reference matching [~S/~S] into a perfect matching // c.matchingSize,c.nbLeftVertices,
        ice/augmentFlow(c))
    else //[MVIEW] reference matching already a perfect matching //,
    let n1 := c.nbLeftVertices, n2 := c.nbRightVertices in
      (//[MVIEW] compute strongly connected components decomposition //,
       firstPassDFS(c), secondPassDFS(c),
       //[MVIEW] remove edges connecting different SCC //,
       for i in (1 .. n1) 
          //[MTALK] left vertex ~S: scc:~S // i,c.component[i],
       for j in (1 .. n2)
          //[MTALK] right vertex ~S: scc:~S // j,c.component[j + n1],
       let nkept := 0, ndiscard := 0 in
          (for i in (1 .. c.nbLeftVertices)
              for j in (mayMatch(c,i) but match(c,i))
                 (if (c.component[i] != c.component[j + n1])
                     (//[MTALK] discard edge ~S ~S // i,j,
                      ndiscard :+ 1,
                      deleteEdgeAndPublish(c,i,j))
                  else nkept :+ 1),
           //[MVIEW] alldiff SCC decomposition: ~S edges kept, ~S discarded // nkept,ndiscard
           ) )]






[removeUselessEdges(c: PalmGlobalCardinality) : void
 -> assert(c.matchingSize = count(list{i in (1 .. c.nbLeftVertices) | match(c,i) != 0})),
    if (c.matchingSize < c.nbLeftVertices)
       (//[MVIEW] complete reference matching [~S/~S] into a perfect matching // c.matchingSize,c.nbLeftVertices,
        ice/augmentFlow(c))
    else //[MVIEW] reference matching already a perfect matching //,
    let n1 := c.nbLeftVertices, n2 := c.nbRightVertices in
      (//[MVIEW] compute strongly connected components decomposition //,
       firstPassDFS(c), secondPassDFS(c),
       //[MVIEW] remove edges connecting different SCC //,
       for i in (1 .. n1) 
          //[MTALK] left vertex ~S: scc:~S // i,c.component[i],
       for j in (1 .. n2)
          //[MTALK] right vertex ~S: scc:~S // j,c.component[j + n1],
       let nkept := 0, ndiscard := 0 in
          (for i in (1 .. c.nbLeftVertices)
              for j in (mayMatch(c,i) but match(c,i))
                 (if (c.component[i] != c.component[j + n1])
                     (//[MTALK] discard edge ~S ~S // i,j,
                      ndiscard :+ 1,
                      deleteEdgeAndPublish(c,i,j))
                  else nkept :+ 1),
           //[MVIEW] alldiff SCC decomposition: ~S edges kept, ~S discarded // nkept,ndiscard
           ) )]


// *************************************************************
// * Part 5 : OCCUR constraint                                 *
// *************************************************************

// * 1 : model 

PalmOccurrence <: choco/Occurrence(
	checkPossible: boolean = false,
	checkSure: boolean = false,
	checkInf: list<boolean>,
	checkSup: list<boolean>
)

// * 2 : propagation Tools                                     

[checkNbPossible(c:PalmOccurrence) : void
 -> assert(count(list{p in c.isPossible | (p = true)}) = c.nbPossible),
    let l := c.vars, n := c.nbVars, nbVar := l[n], tgt := c.cste 
	in (
		if c.constrainOnInfNumber ( 
			let expl := Explanation()
			in (
				self_explain(c, expl),
				for i in {i in (1 .. n - 1) | not(c.isPossible[i])} 
					self_explain(l[i], VAL, tgt, expl),
				updateSup(nbVar, c.nbPossible, c.indices[n], clone(expl)), 
				if (getInf(nbVar) = c.nbPossible) (
					self_explain(nbVar, INF, expl),
					for i in {i in (1 .. n - 1) | c.isPossible[i]} (
						instantiate(l[i], tgt, c.indices[i], clone(expl)) 
					)
				)
			)
		),
		c.checkPossible := false
	)]

[checkNbSure(c:PalmOccurrence) : void
 -> let l := c.vars, n := c.nbVars, nbVar := l[n], tgt := c.cste 
	in (
		assert(c.nbSure <= count(list{i in (1 .. n - 1) | l[i] choco/isInstantiatedTo tgt}) ),
        // equality cannot be guaranteed in the assertion above (valid only at propagation fixpoints)
		if c.constrainOnSupNumber (
			let expl := Explanation() 
			in (
				self_explain(c, expl),
				for i in {i in (1 .. n - 1) | c.isSure[i]}
					self_explain(l[i], DOM, expl),
				updateInf(nbVar, c.nbSure, c.indices[n], clone(expl)), 
				if (getSup(nbVar) = c.nbSure) (
					self_explain(nbVar, SUP, expl),
					//!! it assumes that if c.isPossible[i] = false, tgt does not belong to the domain of l[i]
					assert(forall(i in {i in (1 .. n - 1) | not(c.isPossible[i])}
								  | not(l[i] choco/canBeInstantiatedTo tgt))), //v0.31:associate an assert to the above assumption
					for i in {i in (1 .. n - 1) | (c.isPossible[i] & not(isInstantiated(l[i])))}  ( 
						removeVal(l[i], tgt, c.indices[i], clone(expl)) 
					)
				)
			)
		),
		c.checkSure := false
	)]


// updating DS on reducing the bounds of variable v
[updateDataStructuresOnConstraint(c: PalmOccurrence, idx: integer, way: SELECT, newValue: integer, oldValue: integer) : void
 -> case way (
		{VAL}  (
			if (idx < c.nbVars) (
				if (newValue = c.cste & c.isPossible[idx]) (
					c.isPossible[idx] := false,
					c.nbPossible :- 1,
					c.checkPossible := true,
					if (c.isSure[idx]) ( 
						// Une contradiction va être provoquée : des valeurs vont revenir
						// mais peut-être pas celle qui vient d'être enlevée
						// il faut donc maintenir correctement les structures
						c.isSure[idx] := false,
						c.nbSure :- 1,
						c.checkSure := true
					)
				),
				if (isInstantiated(c.vars[idx])) let val := get(value,c.vars[idx]) // une instantiation vient de se faire 
				in (
					if (val = c.cste & not(c.isSure[idx])) ( // le test sur isSure n'est pas nécessaire 
						c.isSure[idx] := true,
						c.nbSure :+ 1,
						c.checkSure := true
					)
				)
			)
			else (
				c.checkSure := true,
				c.checkPossible := true
			),
			if (newValue < getInf(c.vars[idx])) ( // équivalent d'un updateInf
				c.checkInf[idx] := true
			),
			if (newValue > getSup(c.vars[idx])) ( // équivalent d'un updateSup 
				c.checkSup[idx] := true
			)
		),
		{INF} ( 
			if (idx < c.nbVars) (
				if (c.isPossible[idx] & newValue > c.cste) (
					c.isPossible[idx] := false,
					c.nbPossible :- 1,
					c.checkPossible := true, 
					if (c.isSure[idx]) ( 
						// Une contradiction va être provoquée : des valeurs vont revenir
						// mes peut-être pas celle qui vient d'être enlevée
						// il faut donc maintenir correctement les structures
						c.isSure[idx] := false,
						c.nbSure :- 1,
						c.checkSure := true
					)
				),
				if (isInstantiated(c.vars[idx])) let val := get(value,c.vars[idx]) // une instantiation vient de se faire 
				in (
					if (val = c.cste & not(c.isSure[idx])) ( // le test sur isSure n'est pas nécessaire 
						c.isSure[idx] := true,
						c.nbSure :+ 1,
						c.checkSure := true
					)
				)
			)
			else (
				c.checkSure := true,
				c.checkPossible := true
			)
		), 
		{SUP} (
			if (idx < c.nbVars) (
				if (c.isPossible[idx] & newValue < c.cste) (
					c.isPossible[idx] := false,
					c.nbPossible :- 1,
					c.checkPossible := true, 
					if (c.isSure[idx]) ( 
						// Une contradiction va être provoquée : des valeurs vont revenir
						// mes peut-être pas celle qui vient d'être enlevée
						// il faut donc maintenir correctement les structures
						c.isSure[idx] := false,
						c.nbSure :- 1,
						c.checkSure := true
					)
				),
				if (isInstantiated(c.vars[idx])) let val := get(value,c.vars[idx]) // une instantiation vient de se faire 
				in (
					if (val = c.cste & not(c.isSure[idx])) ( // le test sur isSure n'est pas nécessaire 
						c.isSure[idx] := true,
						c.nbSure :+ 1,
						c.checkSure := true
					)
				)
			)
			else (
				c.checkSure := true,
				c.checkPossible := true
			)
		)
	)]

// updating DS on enlargin the bounds of variable v
[updateDataStructuresOnRestoreConstraint(c: PalmOccurrence, idx: integer, way: SELECT, newValue: integer, oldValue: integer)
 -> case way (
		{VAL} (
			if (idx < c.nbVars) (
				if (newValue = c.cste) (
					if not(c.isPossible[idx]) (
						c.isPossible[idx] := true,
						c.nbPossible :+ 1,
						c.checkPossible := true
					),
					if (isInstantiated(c.vars[idx])) let val := get(value, c.vars[idx])
					in (
						if not(c.isSure[idx]) (
							c.isSure[idx] := true,
							c.nbSure :+ 1,
							c.checkSure := true
						)
					)
				) 
				else if c.isSure[idx] (
					c.isSure[idx] := false,
					c.nbSure :- 1,
					c.checkSure := true				
				)
			) 
			else (
				c.checkPossible := true,
				c.checkSure := true
			),
			c.checkInf[idx] := true,
			c.checkSup[idx] := true
		),
		{INF} (
			if (idx < c.nbVars) (
				if (newValue <= c.cste & oldValue > c.cste & getSup(c.vars[idx]) >= newValue) (
					assert(not(c.isPossible[idx])),
					c.isPossible[idx] := true,
					c.nbPossible :+ 1,
					c.checkPossible := true,
					if (isInstantiated(c.vars[idx])) let val := get(value, c.vars[idx])
					in (
						if (val = c.cste & not(c.isSure[idx])) (
							c.isSure[idx] := true,
							c.nbSure :+ 1,
							c.checkSure := true
						)
						else if (val != c.cste & c.isSure[idx]) (
							c.isSure[idx] := false,
							c.nbSure :- 1,
							c.checkSure := true
						)
					)
				),
				if (c.isSure[idx] & getInf(c.vars[idx]) != c.cste) (
					c.isSure[idx] := false,
					c.nbSure :- 1,
					c.checkSure := true
				)
			)
			else (
				c.checkInf[idx] := true,
				c.checkSup[idx] := true
			)
		),
		{SUP} (
			if (idx < c.nbVars) (
				if (newValue >= c.cste & oldValue < c.cste & getInf(c.vars[idx]) <= newValue) (
					assert(not(c.isPossible[idx])),
					c.isPossible[idx] := true,
					c.nbPossible :+ 1,
					c.checkPossible := true,
					if (isInstantiated(c.vars[idx])) let val := get(value, c.vars[idx])
					in (
						if (val = c.cste & not(c.isSure[idx])) (
							c.isSure[idx] := true,
							c.nbSure :+ 1,
							c.checkSure := true
						)
						else if (val != c.cste & c.isSure[idx]) (
							c.isSure[idx] := false,
							c.nbSure :- 1,
							c.checkSure := true
						)
					)
				),
				if (c.isSure[idx] & getSup(c.vars[idx]) != c.cste) (
					c.isSure[idx] := false,
					c.nbSure :- 1,
					c.checkSure := true
				)
			)
			else (
				c.checkInf[idx] := true,
				c.checkSup[idx] := true
			)
		)
	)]


// <thb> v0.31: There is a smart propagation path, when the variables are BoundIntVar (no bucket):
// When the number of occurrences has already reached its max, then, the additional
// possible occurrences of the value should be forbidden. Therefore whenever the bound
// of a variable reaches the target value, this value can be shaved off and the bound improved by 1.
[awakeOnInf(c:PalmOccurrence, idx:integer) : void
 -> if (idx < c.nbVars) (
		if c.checkPossible
			checkNbPossible(c),
		if c.checkSure
			checkNbSure(c),
		if (c.isPossible[idx] & getInf(c.vars[idx]) = c.cste) (
			if ( not(c.isSure[idx])       // v0.33 <thb>: if the variable is already instantiated, this call to awakeOnInf should do nothing
				  & c.constrainOnSupNumber         // v0.36 <fl>
				  & (c.nbSure = getSup(c.vars[c.nbVars]) )) (
				let expl := Explanation() 
				in (
					self_explain(c, expl),
					self_explain(c.vars[idx], INF, expl),
					self_explain(c.vars[c.nbVars], SUP, expl),
					for i in {i in (1 .. c.nbVars - 1) | c.isSure[i]}
						self_explain(c.vars[i], DOM, expl),
					updateInf(c.vars[idx],c.cste + 1,c.indices[idx], expl)
				) 
			) 
		)
	)
    else checkNbPossible(c),
	c.checkInf[idx] := false]


[awakeOnSup(c:PalmOccurrence, idx:integer) : void
 -> if (idx < c.nbVars) (
		if c.checkPossible
			checkNbPossible(c),
		if c.checkSure
			checkNbSure(c),
		if (c.isPossible[idx] & getSup(c.vars[idx]) >= c.cste) (
			if (not(c.isSure[idx])       // v0.33 <thb>: if the variable is already instantiated, this call to awakeOnInf should do nothing
                 & c.constrainOnSupNumber   // v0.36 <fl>
                 & (c.nbSure = getSup(c.vars[c.nbVars])) ) (
				let expl := Explanation() 
				in (
					self_explain(c, expl),
					self_explain(c.vars[idx], SUP, expl),
					self_explain(c.vars[c.nbVars], SUP, expl),
					for i in {i in (1 .. c.nbVars - 1) | c.isSure[i]}
						self_explain(c.vars[i], DOM, expl),
				   updateSup(c.vars[idx],c.cste - 1,c.indices[idx], expl)
				)
			) 
		)
	)
    else checkNbSure(c),
	c.checkSup[idx] := false]

[awakeOnRem(c:PalmOccurrence, idx:integer, x:integer) : void
 ->	if c.checkPossible (
		checkNbPossible(c)
	),
	if c.checkSure (
		checkNbSure(c)
	),
	if c.checkInf[idx]
		awakeOnInf(c, idx),
	if c.checkSup[idx]
		awakeOnSup(c, idx)]


[awakeOnRestoreInf(c: PalmOccurrence, i: integer) : void
 -> update(c)]
[awakeOnRestoreSup(c: PalmOccurrence, i: integer) : void
 -> update(c)]
[awakeOnRestoreVal(c: PalmOccurrence, i: integer, v: integer) : void
 -> update(c)]


[awake(c:PalmOccurrence) : void
 -> // [0] awake(c:PalmOccurrence) called,
 	// v1.0 two first easy inferences
    let n := c.nbVars, nbVar := c.vars[n], e := Explanation() in
      (self_explain(c, e),
		if c.constrainOnInfNumber updateSup(nbVar, n, c.indices[n], clone(e)),
        if c.constrainOnSupNumber updateInf(nbVar, 0, c.indices[n], clone(e))),
    propagate(c),
    // [0] awake(c:PalmOccurrence) done,
    nil
]


// <thb> v0.93
[testIfSatisfied(c:PalmOccurrence) : boolean -> true]
 
// <thb> v0.93
[askIfEntailed(c:PalmOccurrence) : (boolean U {unknown})
 -> let occ := c.vars[c.nbVars],
        nbS := count(list{i in (1 .. c.nbVars - 1) | c.vars[i] choco/isInstantiatedTo c.cste}),
        nbP := count(list{i in (1 .. c.nbVars - 1) | c.vars[i] choco/canBeInstantiatedTo c.cste}) in
        (if (c.constrainOnSupNumber & c.constrainOnInfNumber)
             (if (isInstantiated(occ) & (nbS = nbP) & (occ.value = nbS)) true 
              else if (nbP < getInf(occ) | nbS > getSup(occ)) false
              else unknown)         
         else if c.constrainOnInfNumber    
             (if (nbS >= getSup(occ)) true 
              else if (nbP < getInf(occ)) false
              else unknown)
         else if c.constrainOnSupNumber 
             (if (nbP <= getInf(occ)) true 
              else if (nbS > getSup(occ)) false
              else unknown)
         else error("Stop and debug: constrainOnSupNumber or constrainOnInfNumber must be true in PalmOccurrence"))]


[checkPalm(ct: PalmOccurrence) : boolean -> true]
// claire3 port register no longer used
;;(#if (compiler.active? & compiler.loading?) register(PalmOccurrence))


// ********************************************************************
// *  Part 6: accessing the ith element in a list of values           *
// ********************************************************************

// Element constraint
//   (accessing the ith element in a list of values, where i is a variable)
// the slot v1 represents the index and the slot v2 represents the value
// propagation with complete arc consistency from values to indices (v2 to v1)
// propagation with interval approximation from indices to values (v1 to v2)

PalmElt <: choco/Elt()

// v0.34 uses the cste slot: l[i + cste] = x
// (ex: cste = 1 allows to use and index from 0 to length(l) - 1
// v0.9907: removed the method without the last argument
[makePalmEltConstraint(l:list[integer], i:PalmIntVar, x:PalmIntVar, o:integer) : PalmElt
 -> let c := PalmElt(v1 = i, v2 = x, cste = o, lval = copy(l)) in 
     (initHook(c),c)]

// v0.25 <fl> replaced all removeVal by remVal (in order to propagate induced consequences)
// v0.26 a few casts
[updateValueFromIndex(c:PalmElt) : void
 -> let l := c.lval, indexVar := c.v1, valueVar := c.v2, minval := MAXINT, maxval := MININT, e := Explanation() in
      (self_explain(c,e),self_explain(indexVar,DOM,e),
       for feasibleIndex in domain(indexVar)
         (minval :min (l[feasibleIndex + c.cste] as integer),
          maxval :max (l[feasibleIndex + c.cste] as integer)),
       updateInf(valueVar, minval, c.idx2,clone(e)),
       updateSup(valueVar, maxval, c.idx2,clone(e)),
        
       //v1.0: propagate on holes when valueVar has an enumerated domain
       if known?(bucket,valueVar) 
           for v in list{v in domain(valueVar) | not(exists(i in domain(indexVar) | v = l[i + c.cste]))}
               removeVal(valueVar,v,c.idx2,clone(e)) )] 
       
       
// v0.29: The constraint must enforce that valueVar takes a value among l, which may be a sequence of values with holes.
// When valueVar is represented as an enumeration of values (with v.bucket), this is enforced from the start
// (when the constraint is posted).
// otherwise, when valueVar is only reperesented by its domain bounds, each time a value is removed from its domain
// we need not only to restrict indexVar, but also to propagate back the new bounds for valueVar.
// Thus, the consequences of this function on indexVar must be posted and propagated back to the PalmElt constraint
// therefore, we replace the cause of the event on indexVar (c.idx1) by 0 => the PalmElt constraint will be re-awaken later
// with a call to updateValueFromIndex which will recompute the min/max for valueVar
;[updateIndexFromValue(c:PalmElt) : void
; -> let l := c.lval,n := length(l),
;        indexVar := c.v1, valueVar := c.v2,
;        minFeasibleIndex := max(1 - c.cste,getInf(indexVar)),
;        maxFeasibleIndex := min(getSup(indexVar),n - c.cste),
;        thecause := (if known?(bucket,valueVar) c.idx1 else 0),
;        e := Explanation() in // v0.28: size vs. length
;     (self_explain(c,e),self_explain(valueVar,DOM,e),       
;      while ((indexVar choco/canBeInstantiatedTo minFeasibleIndex) &
;             not(valueVar choco/canBeInstantiatedTo l[minFeasibleIndex + c.cste])) minFeasibleIndex :+ 1,
;      updateInf(indexVar,minFeasibleIndex,thecause,clone(e)),
;      while ((indexVar choco/canBeInstantiatedTo maxFeasibleIndex) &
;             not(valueVar choco/canBeInstantiatedTo l[maxFeasibleIndex + c.cste])) maxFeasibleIndex :- 1,
;      updateSup(indexVar,maxFeasibleIndex,thecause,clone(e)),
;      if (known?(bucket,indexVar))  //those remVal would be ignored for variables using an interval approximation for domain
;         for i in (minFeasibleIndex + 1 .. maxFeasibleIndex - 1)
;            (if ((indexVar choco/canBeInstantiatedTo i) & not(valueVar choco/canBeInstantiatedTo l[i + c.cste]))
;                removeVal(indexVar, i, thecause,clone(e))) )]

;<thb> new version 21/06/01
 
[updateIndexFromValue(c:PalmElt) : void
 -> let l := c.lval,n := length(l),
        indexVar := c.v1, valueVar := c.v2,
        minFeasibleIndex := max(1 - c.cste,indexVar.inf),
        maxFeasibleIndex := min(indexVar.sup,n - c.cste),
        thecause := (if known?(bucket,valueVar) c.idx1 else 0),
        e := Explanation() in // v0.28: size vs. length
     (self_explain(c,e),self_explain(valueVar,DOM,e),       
      while ((indexVar choco/canBeInstantiatedTo minFeasibleIndex) &
             not(valueVar choco/canBeInstantiatedTo l[minFeasibleIndex + c.cste])) minFeasibleIndex :+ 1,
      updateInf(indexVar,minFeasibleIndex,thecause,clone(e)),
      while ((indexVar choco/canBeInstantiatedTo maxFeasibleIndex) &
             not(valueVar choco/canBeInstantiatedTo l[maxFeasibleIndex + c.cste])) maxFeasibleIndex :- 1,
      updateSup(indexVar,maxFeasibleIndex,thecause,clone(e)),
      if (known?(bucket,indexVar))  //those remVal would be ignored for variables using an interval approximation for domain
         for i in (minFeasibleIndex + 1 .. maxFeasibleIndex - 1)
            (if ((indexVar choco/canBeInstantiatedTo i) & not(valueVar choco/canBeInstantiatedTo l[i + c.cste]))
                let erem := Explanation() in 
                    (self_explain(c,erem),self_explain(valueVar,VAL,l[i + c.cste],erem),   
                     removeVal(indexVar, i, thecause, erem))) )]
 


// v0.9907: at initialization time, we propagate once for good the fact that:
//   - indices must be in the right range for accessing the integer table 
//   - all values in the domain of valueVar must correspond to a value in l 
[awake(c:PalmElt) : void
 -> // [0] awake(c:PalmElt) called,
 	let l := c.lval, n := length(c.lval), o := c.cste, indexVar := c.v1, valueVar := c.v2, e := Explanation() in
       (self_explain(c,e),
        updateInf(indexVar,1 - o,c.idx1,clone(e)), updateSup(indexVar,n - o,c.idx1,clone(e)),        
        propagate(c)),
        // [0] awake(c:PalmElt) done,
        nil
]
        
[propagate(c:PalmElt) : void
 -> updateIndexFromValue(c), 
    updateValueFromIndex(c)]

[awakeOnInf(c:PalmElt, idx:integer) : void
 -> if (idx = 1) updateValueFromIndex(c)
    else updateIndexFromValue(c)]

[awakeOnSup(c:PalmElt, idx:integer) : void
 -> if (idx = 1) updateValueFromIndex(c)
    else updateIndexFromValue(c)]

[awakeOnInst(c:PalmElt, idx:integer) : void
 -> if (idx = 1) instantiate(c.v2, c.lval[c.v1.value + c.cste],c.idx2)
    else updateIndexFromValue(c)]

// v0.33 <thb>: in case a value is no longer feasible, we need to upate the index.
// Note that we call updateIndexFrom Value rather than only removing the i such that l[i]=x
// from the domain of the index variable.
// This is due to the case of interval approximation for value Var (in this case,
// one single call to updateIndexFromValue reaches fix point saturation)
[awakeOnRem(c:PalmElt, idx:integer,x:integer) : void
 -> if (idx = 1) updateValueFromIndex(c)
    else updateIndexFromValue(c)]


//all restorations have the same behavior
[awakeOnRestore(c:PalmElt,idx:integer) : void
-> let n := length(c.lval), o := c.cste, indexVar := c.v1, e := Explanation() in
    (self_explain(c,e),
     updateInf(indexVar,1 - o,c.idx1,clone(e)),
     updateSup(indexVar,n - o,c.idx1,clone(e))),                   
   if (idx = 1) updateIndexFromValue(c)
   else updateValueFromIndex(c)]
    
[awakeOnRestoreInf(c:PalmElt,idx:integer) : void => awakeOnRestore(c,idx)]        
[awakeOnRestoreSup(c:PalmElt,idx:integer) : void => awakeOnRestore(c,idx)]        
[awakeOnRestoreVal(c:PalmElt,idx:integer,v:integer) : void => awakeOnRestore(c,idx)]        


//v0.93: askIfEntailed can be called before any awake (in bool combinations)
//       Therefore we cannot assume that all values of domain(indexVar) lead to "in scope" indexes for the list.
//       -> added tests (idx + c.cste) % (1 .. length(l))
[askIfEntailed(c:PalmElt) : (boolean U {unknown})  // v0.26 wrong interface (was askIfTrue)
 -> let l := c.lval, indexVar := c.v1, valueVar := c.v2 in
       (// If the value is known, test whether all possible values of indexVar + cste are 
        // valid indexes pointing to the correct value
        if (isInstantiated(valueVar) &
            forall(idx in domain(indexVar) | 
                      ((idx + c.cste) % (1 .. length(l))) & (l[idx + c.cste] = valueVar.value)))
          true
        // Otherwise test just test whether indexVar + cste can be a valid index pointing to a possible value  
        else if exists(idx in domain(indexVar) |
                         ((idx + c.cste) % (1 .. length(l))) & (valueVar choco/canBeInstantiatedTo l[idx + c.cste]))
          unknown
        else false)]

[testIfSatisfied(c:PalmElt) : boolean        // v0.26 wrong interface (was checkIfSatisfied)
 -> assert(isInstantiated(c.v1) & isInstantiated(c.v2)),
    c.lval[c.v1.value + c.cste] = c.v2.value]


[whyTrueOrFalse(c: PalmElt) : set[AbstractConstraint]
 -> let expl := Explanation() 
    in (self_explain(c.v1, DOM, expl),
		self_explain(c.v2, DOM, expl),		
		set!(expl)
	)]


[whyIsFalse(c: PalmElt) : set[AbstractConstraint] => whyTrueOrFalse(c)]
[whyIsTrue(c: PalmElt) : set[AbstractConstraint] => whyTrueOrFalse(c)]


[checkPalm(ct: PalmElt) : boolean -> true]
// v0.34
// claire3 port register no longer used
;;(#if (compiler.active? & compiler.loading?) register(PalmElt))
